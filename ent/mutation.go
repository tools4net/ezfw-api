// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/tools4net/ezfw/backend/ent/agenttoken"
	"github.com/tools4net/ezfw/backend/ent/haproxyconfig"
	"github.com/tools4net/ezfw/backend/ent/node"
	"github.com/tools4net/ezfw/backend/ent/predicate"
	"github.com/tools4net/ezfw/backend/ent/serviceinstance"
	"github.com/tools4net/ezfw/backend/ent/singboxconfig"
	"github.com/tools4net/ezfw/backend/ent/xrayconfig"
	"github.com/tools4net/ezfw/backend/internal/models"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgentToken      = "AgentToken"
	TypeHAProxyConfig   = "HAProxyConfig"
	TypeNode            = "Node"
	TypeServiceInstance = "ServiceInstance"
	TypeSingBoxConfig   = "SingBoxConfig"
	TypeXrayConfig      = "XrayConfig"
)

// AgentTokenMutation represents an operation that mutates the AgentToken nodes in the graph.
type AgentTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	token         *string
	name          *string
	status        *string
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	last_used     *time.Time
	clearedFields map[string]struct{}
	node          *string
	clearednode   bool
	done          bool
	oldValue      func(context.Context) (*AgentToken, error)
	predicates    []predicate.AgentToken
}

var _ ent.Mutation = (*AgentTokenMutation)(nil)

// agenttokenOption allows management of the mutation configuration using functional options.
type agenttokenOption func(*AgentTokenMutation)

// newAgentTokenMutation creates new mutation for the AgentToken entity.
func newAgentTokenMutation(c config, op Op, opts ...agenttokenOption) *AgentTokenMutation {
	m := &AgentTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentTokenID sets the ID field of the mutation.
func withAgentTokenID(id string) agenttokenOption {
	return func(m *AgentTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentToken
		)
		m.oldValue = func(ctx context.Context) (*AgentToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentToken sets the old AgentToken of the mutation.
func withAgentToken(node *AgentToken) agenttokenOption {
	return func(m *AgentTokenMutation) {
		m.oldValue = func(context.Context) (*AgentToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentToken entities.
func (m *AgentTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *AgentTokenMutation) SetNodeID(s string) {
	m.node = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *AgentTokenMutation) NodeID() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *AgentTokenMutation) ResetNodeID() {
	m.node = nil
}

// SetToken sets the "token" field.
func (m *AgentTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AgentTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AgentTokenMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *AgentTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AgentTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AgentTokenMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *AgentTokenMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentTokenMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentTokenMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AgentTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AgentTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AgentTokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[agenttoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AgentTokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[agenttoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AgentTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, agenttoken.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastUsed sets the "last_used" field.
func (m *AgentTokenMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *AgentTokenMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the AgentToken entity.
// If the AgentToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTokenMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *AgentTokenMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[agenttoken.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *AgentTokenMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[agenttoken.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *AgentTokenMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, agenttoken.FieldLastUsed)
}

// ClearNode clears the "node" edge to the Node entity.
func (m *AgentTokenMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[agenttoken.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *AgentTokenMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *AgentTokenMutation) NodeIDs() (ids []string) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *AgentTokenMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the AgentTokenMutation builder.
func (m *AgentTokenMutation) Where(ps ...predicate.AgentToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentToken).
func (m *AgentTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.node != nil {
		fields = append(fields, agenttoken.FieldNodeID)
	}
	if m.token != nil {
		fields = append(fields, agenttoken.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, agenttoken.FieldName)
	}
	if m.status != nil {
		fields = append(fields, agenttoken.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, agenttoken.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, agenttoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agenttoken.FieldUpdatedAt)
	}
	if m.last_used != nil {
		fields = append(fields, agenttoken.FieldLastUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenttoken.FieldNodeID:
		return m.NodeID()
	case agenttoken.FieldToken:
		return m.Token()
	case agenttoken.FieldName:
		return m.Name()
	case agenttoken.FieldStatus:
		return m.Status()
	case agenttoken.FieldExpiresAt:
		return m.ExpiresAt()
	case agenttoken.FieldCreatedAt:
		return m.CreatedAt()
	case agenttoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case agenttoken.FieldLastUsed:
		return m.LastUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenttoken.FieldNodeID:
		return m.OldNodeID(ctx)
	case agenttoken.FieldToken:
		return m.OldToken(ctx)
	case agenttoken.FieldName:
		return m.OldName(ctx)
	case agenttoken.FieldStatus:
		return m.OldStatus(ctx)
	case agenttoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case agenttoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agenttoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agenttoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	}
	return nil, fmt.Errorf("unknown AgentToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenttoken.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case agenttoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case agenttoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case agenttoken.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agenttoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case agenttoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agenttoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agenttoken.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	}
	return fmt.Errorf("unknown AgentToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AgentToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agenttoken.FieldExpiresAt) {
		fields = append(fields, agenttoken.FieldExpiresAt)
	}
	if m.FieldCleared(agenttoken.FieldLastUsed) {
		fields = append(fields, agenttoken.FieldLastUsed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentTokenMutation) ClearField(name string) error {
	switch name {
	case agenttoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case agenttoken.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	}
	return fmt.Errorf("unknown AgentToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentTokenMutation) ResetField(name string) error {
	switch name {
	case agenttoken.FieldNodeID:
		m.ResetNodeID()
		return nil
	case agenttoken.FieldToken:
		m.ResetToken()
		return nil
	case agenttoken.FieldName:
		m.ResetName()
		return nil
	case agenttoken.FieldStatus:
		m.ResetStatus()
		return nil
	case agenttoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case agenttoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agenttoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agenttoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	}
	return fmt.Errorf("unknown AgentToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.node != nil {
		edges = append(edges, agenttoken.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenttoken.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednode {
		edges = append(edges, agenttoken.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case agenttoken.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentTokenMutation) ClearEdge(name string) error {
	switch name {
	case agenttoken.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown AgentToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentTokenMutation) ResetEdge(name string) error {
	switch name {
	case agenttoken.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown AgentToken edge %s", name)
}

// HAProxyConfigMutation represents an operation that mutates the HAProxyConfig nodes in the graph.
type HAProxyConfigMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	description     *string
	created_at      *time.Time
	updated_at      *time.Time
	global_config   **models.HAProxyGlobal
	defaults_config **models.HAProxyDefaults
	frontends       *[]models.HAProxyFrontend
	appendfrontends []models.HAProxyFrontend
	backends        *[]models.HAProxyBackend
	appendbackends  []models.HAProxyBackend
	listens         *[]models.HAProxyListen
	appendlistens   []models.HAProxyListen
	stats_config    **models.HAProxyStats
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*HAProxyConfig, error)
	predicates      []predicate.HAProxyConfig
}

var _ ent.Mutation = (*HAProxyConfigMutation)(nil)

// haproxyconfigOption allows management of the mutation configuration using functional options.
type haproxyconfigOption func(*HAProxyConfigMutation)

// newHAProxyConfigMutation creates new mutation for the HAProxyConfig entity.
func newHAProxyConfigMutation(c config, op Op, opts ...haproxyconfigOption) *HAProxyConfigMutation {
	m := &HAProxyConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeHAProxyConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHAProxyConfigID sets the ID field of the mutation.
func withHAProxyConfigID(id string) haproxyconfigOption {
	return func(m *HAProxyConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *HAProxyConfig
		)
		m.oldValue = func(ctx context.Context) (*HAProxyConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HAProxyConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHAProxyConfig sets the old HAProxyConfig of the mutation.
func withHAProxyConfig(node *HAProxyConfig) haproxyconfigOption {
	return func(m *HAProxyConfigMutation) {
		m.oldValue = func(context.Context) (*HAProxyConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HAProxyConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HAProxyConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HAProxyConfig entities.
func (m *HAProxyConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HAProxyConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HAProxyConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HAProxyConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HAProxyConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HAProxyConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HAProxyConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HAProxyConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HAProxyConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HAProxyConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[haproxyconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HAProxyConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HAProxyConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, haproxyconfig.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *HAProxyConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HAProxyConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HAProxyConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HAProxyConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HAProxyConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HAProxyConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGlobalConfig sets the "global_config" field.
func (m *HAProxyConfigMutation) SetGlobalConfig(mpg *models.HAProxyGlobal) {
	m.global_config = &mpg
}

// GlobalConfig returns the value of the "global_config" field in the mutation.
func (m *HAProxyConfigMutation) GlobalConfig() (r *models.HAProxyGlobal, exists bool) {
	v := m.global_config
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalConfig returns the old "global_config" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldGlobalConfig(ctx context.Context) (v *models.HAProxyGlobal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalConfig: %w", err)
	}
	return oldValue.GlobalConfig, nil
}

// ClearGlobalConfig clears the value of the "global_config" field.
func (m *HAProxyConfigMutation) ClearGlobalConfig() {
	m.global_config = nil
	m.clearedFields[haproxyconfig.FieldGlobalConfig] = struct{}{}
}

// GlobalConfigCleared returns if the "global_config" field was cleared in this mutation.
func (m *HAProxyConfigMutation) GlobalConfigCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldGlobalConfig]
	return ok
}

// ResetGlobalConfig resets all changes to the "global_config" field.
func (m *HAProxyConfigMutation) ResetGlobalConfig() {
	m.global_config = nil
	delete(m.clearedFields, haproxyconfig.FieldGlobalConfig)
}

// SetDefaultsConfig sets the "defaults_config" field.
func (m *HAProxyConfigMutation) SetDefaultsConfig(mpd *models.HAProxyDefaults) {
	m.defaults_config = &mpd
}

// DefaultsConfig returns the value of the "defaults_config" field in the mutation.
func (m *HAProxyConfigMutation) DefaultsConfig() (r *models.HAProxyDefaults, exists bool) {
	v := m.defaults_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultsConfig returns the old "defaults_config" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldDefaultsConfig(ctx context.Context) (v *models.HAProxyDefaults, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultsConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultsConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultsConfig: %w", err)
	}
	return oldValue.DefaultsConfig, nil
}

// ClearDefaultsConfig clears the value of the "defaults_config" field.
func (m *HAProxyConfigMutation) ClearDefaultsConfig() {
	m.defaults_config = nil
	m.clearedFields[haproxyconfig.FieldDefaultsConfig] = struct{}{}
}

// DefaultsConfigCleared returns if the "defaults_config" field was cleared in this mutation.
func (m *HAProxyConfigMutation) DefaultsConfigCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldDefaultsConfig]
	return ok
}

// ResetDefaultsConfig resets all changes to the "defaults_config" field.
func (m *HAProxyConfigMutation) ResetDefaultsConfig() {
	m.defaults_config = nil
	delete(m.clearedFields, haproxyconfig.FieldDefaultsConfig)
}

// SetFrontends sets the "frontends" field.
func (m *HAProxyConfigMutation) SetFrontends(mpf []models.HAProxyFrontend) {
	m.frontends = &mpf
	m.appendfrontends = nil
}

// Frontends returns the value of the "frontends" field in the mutation.
func (m *HAProxyConfigMutation) Frontends() (r []models.HAProxyFrontend, exists bool) {
	v := m.frontends
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontends returns the old "frontends" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldFrontends(ctx context.Context) (v []models.HAProxyFrontend, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontends: %w", err)
	}
	return oldValue.Frontends, nil
}

// AppendFrontends adds mpf to the "frontends" field.
func (m *HAProxyConfigMutation) AppendFrontends(mpf []models.HAProxyFrontend) {
	m.appendfrontends = append(m.appendfrontends, mpf...)
}

// AppendedFrontends returns the list of values that were appended to the "frontends" field in this mutation.
func (m *HAProxyConfigMutation) AppendedFrontends() ([]models.HAProxyFrontend, bool) {
	if len(m.appendfrontends) == 0 {
		return nil, false
	}
	return m.appendfrontends, true
}

// ClearFrontends clears the value of the "frontends" field.
func (m *HAProxyConfigMutation) ClearFrontends() {
	m.frontends = nil
	m.appendfrontends = nil
	m.clearedFields[haproxyconfig.FieldFrontends] = struct{}{}
}

// FrontendsCleared returns if the "frontends" field was cleared in this mutation.
func (m *HAProxyConfigMutation) FrontendsCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldFrontends]
	return ok
}

// ResetFrontends resets all changes to the "frontends" field.
func (m *HAProxyConfigMutation) ResetFrontends() {
	m.frontends = nil
	m.appendfrontends = nil
	delete(m.clearedFields, haproxyconfig.FieldFrontends)
}

// SetBackends sets the "backends" field.
func (m *HAProxyConfigMutation) SetBackends(mpb []models.HAProxyBackend) {
	m.backends = &mpb
	m.appendbackends = nil
}

// Backends returns the value of the "backends" field in the mutation.
func (m *HAProxyConfigMutation) Backends() (r []models.HAProxyBackend, exists bool) {
	v := m.backends
	if v == nil {
		return
	}
	return *v, true
}

// OldBackends returns the old "backends" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldBackends(ctx context.Context) (v []models.HAProxyBackend, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackends: %w", err)
	}
	return oldValue.Backends, nil
}

// AppendBackends adds mpb to the "backends" field.
func (m *HAProxyConfigMutation) AppendBackends(mpb []models.HAProxyBackend) {
	m.appendbackends = append(m.appendbackends, mpb...)
}

// AppendedBackends returns the list of values that were appended to the "backends" field in this mutation.
func (m *HAProxyConfigMutation) AppendedBackends() ([]models.HAProxyBackend, bool) {
	if len(m.appendbackends) == 0 {
		return nil, false
	}
	return m.appendbackends, true
}

// ClearBackends clears the value of the "backends" field.
func (m *HAProxyConfigMutation) ClearBackends() {
	m.backends = nil
	m.appendbackends = nil
	m.clearedFields[haproxyconfig.FieldBackends] = struct{}{}
}

// BackendsCleared returns if the "backends" field was cleared in this mutation.
func (m *HAProxyConfigMutation) BackendsCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldBackends]
	return ok
}

// ResetBackends resets all changes to the "backends" field.
func (m *HAProxyConfigMutation) ResetBackends() {
	m.backends = nil
	m.appendbackends = nil
	delete(m.clearedFields, haproxyconfig.FieldBackends)
}

// SetListens sets the "listens" field.
func (m *HAProxyConfigMutation) SetListens(mpl []models.HAProxyListen) {
	m.listens = &mpl
	m.appendlistens = nil
}

// Listens returns the value of the "listens" field in the mutation.
func (m *HAProxyConfigMutation) Listens() (r []models.HAProxyListen, exists bool) {
	v := m.listens
	if v == nil {
		return
	}
	return *v, true
}

// OldListens returns the old "listens" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldListens(ctx context.Context) (v []models.HAProxyListen, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListens: %w", err)
	}
	return oldValue.Listens, nil
}

// AppendListens adds mpl to the "listens" field.
func (m *HAProxyConfigMutation) AppendListens(mpl []models.HAProxyListen) {
	m.appendlistens = append(m.appendlistens, mpl...)
}

// AppendedListens returns the list of values that were appended to the "listens" field in this mutation.
func (m *HAProxyConfigMutation) AppendedListens() ([]models.HAProxyListen, bool) {
	if len(m.appendlistens) == 0 {
		return nil, false
	}
	return m.appendlistens, true
}

// ClearListens clears the value of the "listens" field.
func (m *HAProxyConfigMutation) ClearListens() {
	m.listens = nil
	m.appendlistens = nil
	m.clearedFields[haproxyconfig.FieldListens] = struct{}{}
}

// ListensCleared returns if the "listens" field was cleared in this mutation.
func (m *HAProxyConfigMutation) ListensCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldListens]
	return ok
}

// ResetListens resets all changes to the "listens" field.
func (m *HAProxyConfigMutation) ResetListens() {
	m.listens = nil
	m.appendlistens = nil
	delete(m.clearedFields, haproxyconfig.FieldListens)
}

// SetStatsConfig sets the "stats_config" field.
func (m *HAProxyConfigMutation) SetStatsConfig(mps *models.HAProxyStats) {
	m.stats_config = &mps
}

// StatsConfig returns the value of the "stats_config" field in the mutation.
func (m *HAProxyConfigMutation) StatsConfig() (r *models.HAProxyStats, exists bool) {
	v := m.stats_config
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsConfig returns the old "stats_config" field's value of the HAProxyConfig entity.
// If the HAProxyConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HAProxyConfigMutation) OldStatsConfig(ctx context.Context) (v *models.HAProxyStats, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsConfig: %w", err)
	}
	return oldValue.StatsConfig, nil
}

// ClearStatsConfig clears the value of the "stats_config" field.
func (m *HAProxyConfigMutation) ClearStatsConfig() {
	m.stats_config = nil
	m.clearedFields[haproxyconfig.FieldStatsConfig] = struct{}{}
}

// StatsConfigCleared returns if the "stats_config" field was cleared in this mutation.
func (m *HAProxyConfigMutation) StatsConfigCleared() bool {
	_, ok := m.clearedFields[haproxyconfig.FieldStatsConfig]
	return ok
}

// ResetStatsConfig resets all changes to the "stats_config" field.
func (m *HAProxyConfigMutation) ResetStatsConfig() {
	m.stats_config = nil
	delete(m.clearedFields, haproxyconfig.FieldStatsConfig)
}

// Where appends a list predicates to the HAProxyConfigMutation builder.
func (m *HAProxyConfigMutation) Where(ps ...predicate.HAProxyConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HAProxyConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HAProxyConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HAProxyConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HAProxyConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HAProxyConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HAProxyConfig).
func (m *HAProxyConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HAProxyConfigMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, haproxyconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, haproxyconfig.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, haproxyconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, haproxyconfig.FieldUpdatedAt)
	}
	if m.global_config != nil {
		fields = append(fields, haproxyconfig.FieldGlobalConfig)
	}
	if m.defaults_config != nil {
		fields = append(fields, haproxyconfig.FieldDefaultsConfig)
	}
	if m.frontends != nil {
		fields = append(fields, haproxyconfig.FieldFrontends)
	}
	if m.backends != nil {
		fields = append(fields, haproxyconfig.FieldBackends)
	}
	if m.listens != nil {
		fields = append(fields, haproxyconfig.FieldListens)
	}
	if m.stats_config != nil {
		fields = append(fields, haproxyconfig.FieldStatsConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HAProxyConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case haproxyconfig.FieldName:
		return m.Name()
	case haproxyconfig.FieldDescription:
		return m.Description()
	case haproxyconfig.FieldCreatedAt:
		return m.CreatedAt()
	case haproxyconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case haproxyconfig.FieldGlobalConfig:
		return m.GlobalConfig()
	case haproxyconfig.FieldDefaultsConfig:
		return m.DefaultsConfig()
	case haproxyconfig.FieldFrontends:
		return m.Frontends()
	case haproxyconfig.FieldBackends:
		return m.Backends()
	case haproxyconfig.FieldListens:
		return m.Listens()
	case haproxyconfig.FieldStatsConfig:
		return m.StatsConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HAProxyConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case haproxyconfig.FieldName:
		return m.OldName(ctx)
	case haproxyconfig.FieldDescription:
		return m.OldDescription(ctx)
	case haproxyconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case haproxyconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case haproxyconfig.FieldGlobalConfig:
		return m.OldGlobalConfig(ctx)
	case haproxyconfig.FieldDefaultsConfig:
		return m.OldDefaultsConfig(ctx)
	case haproxyconfig.FieldFrontends:
		return m.OldFrontends(ctx)
	case haproxyconfig.FieldBackends:
		return m.OldBackends(ctx)
	case haproxyconfig.FieldListens:
		return m.OldListens(ctx)
	case haproxyconfig.FieldStatsConfig:
		return m.OldStatsConfig(ctx)
	}
	return nil, fmt.Errorf("unknown HAProxyConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HAProxyConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case haproxyconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case haproxyconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case haproxyconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case haproxyconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case haproxyconfig.FieldGlobalConfig:
		v, ok := value.(*models.HAProxyGlobal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalConfig(v)
		return nil
	case haproxyconfig.FieldDefaultsConfig:
		v, ok := value.(*models.HAProxyDefaults)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultsConfig(v)
		return nil
	case haproxyconfig.FieldFrontends:
		v, ok := value.([]models.HAProxyFrontend)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontends(v)
		return nil
	case haproxyconfig.FieldBackends:
		v, ok := value.([]models.HAProxyBackend)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackends(v)
		return nil
	case haproxyconfig.FieldListens:
		v, ok := value.([]models.HAProxyListen)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListens(v)
		return nil
	case haproxyconfig.FieldStatsConfig:
		v, ok := value.(*models.HAProxyStats)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsConfig(v)
		return nil
	}
	return fmt.Errorf("unknown HAProxyConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HAProxyConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HAProxyConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HAProxyConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HAProxyConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HAProxyConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(haproxyconfig.FieldDescription) {
		fields = append(fields, haproxyconfig.FieldDescription)
	}
	if m.FieldCleared(haproxyconfig.FieldGlobalConfig) {
		fields = append(fields, haproxyconfig.FieldGlobalConfig)
	}
	if m.FieldCleared(haproxyconfig.FieldDefaultsConfig) {
		fields = append(fields, haproxyconfig.FieldDefaultsConfig)
	}
	if m.FieldCleared(haproxyconfig.FieldFrontends) {
		fields = append(fields, haproxyconfig.FieldFrontends)
	}
	if m.FieldCleared(haproxyconfig.FieldBackends) {
		fields = append(fields, haproxyconfig.FieldBackends)
	}
	if m.FieldCleared(haproxyconfig.FieldListens) {
		fields = append(fields, haproxyconfig.FieldListens)
	}
	if m.FieldCleared(haproxyconfig.FieldStatsConfig) {
		fields = append(fields, haproxyconfig.FieldStatsConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HAProxyConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HAProxyConfigMutation) ClearField(name string) error {
	switch name {
	case haproxyconfig.FieldDescription:
		m.ClearDescription()
		return nil
	case haproxyconfig.FieldGlobalConfig:
		m.ClearGlobalConfig()
		return nil
	case haproxyconfig.FieldDefaultsConfig:
		m.ClearDefaultsConfig()
		return nil
	case haproxyconfig.FieldFrontends:
		m.ClearFrontends()
		return nil
	case haproxyconfig.FieldBackends:
		m.ClearBackends()
		return nil
	case haproxyconfig.FieldListens:
		m.ClearListens()
		return nil
	case haproxyconfig.FieldStatsConfig:
		m.ClearStatsConfig()
		return nil
	}
	return fmt.Errorf("unknown HAProxyConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HAProxyConfigMutation) ResetField(name string) error {
	switch name {
	case haproxyconfig.FieldName:
		m.ResetName()
		return nil
	case haproxyconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case haproxyconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case haproxyconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case haproxyconfig.FieldGlobalConfig:
		m.ResetGlobalConfig()
		return nil
	case haproxyconfig.FieldDefaultsConfig:
		m.ResetDefaultsConfig()
		return nil
	case haproxyconfig.FieldFrontends:
		m.ResetFrontends()
		return nil
	case haproxyconfig.FieldBackends:
		m.ResetBackends()
		return nil
	case haproxyconfig.FieldListens:
		m.ResetListens()
		return nil
	case haproxyconfig.FieldStatsConfig:
		m.ResetStatsConfig()
		return nil
	}
	return fmt.Errorf("unknown HAProxyConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HAProxyConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HAProxyConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HAProxyConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HAProxyConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HAProxyConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HAProxyConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HAProxyConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HAProxyConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HAProxyConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HAProxyConfig edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	description              *string
	hostname                 *string
	ip_address               *string
	port                     *int
	addport                  *int
	status                   *string
	os_info                  **models.OSInfo
	agent_info               **models.AgentInfo
	tags                     *[]string
	appendtags               []string
	created_at               *time.Time
	updated_at               *time.Time
	last_seen                *time.Time
	clearedFields            map[string]struct{}
	service_instances        map[string]struct{}
	removedservice_instances map[string]struct{}
	clearedservice_instances bool
	agent_tokens             map[string]struct{}
	removedagent_tokens      map[string]struct{}
	clearedagent_tokens      bool
	done                     bool
	oldValue                 func(context.Context) (*Node, error)
	predicates               []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id string) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Node entities.
func (m *NodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[node.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[node.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, node.FieldDescription)
}

// SetHostname sets the "hostname" field.
func (m *NodeMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *NodeMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *NodeMutation) ResetHostname() {
	m.hostname = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *NodeMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *NodeMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *NodeMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetPort sets the "port" field.
func (m *NodeMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *NodeMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *NodeMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *NodeMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *NodeMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetStatus sets the "status" field.
func (m *NodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *NodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NodeMutation) ResetStatus() {
	m.status = nil
}

// SetOsInfo sets the "os_info" field.
func (m *NodeMutation) SetOsInfo(mi *models.OSInfo) {
	m.os_info = &mi
}

// OsInfo returns the value of the "os_info" field in the mutation.
func (m *NodeMutation) OsInfo() (r *models.OSInfo, exists bool) {
	v := m.os_info
	if v == nil {
		return
	}
	return *v, true
}

// OldOsInfo returns the old "os_info" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldOsInfo(ctx context.Context) (v *models.OSInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsInfo: %w", err)
	}
	return oldValue.OsInfo, nil
}

// ClearOsInfo clears the value of the "os_info" field.
func (m *NodeMutation) ClearOsInfo() {
	m.os_info = nil
	m.clearedFields[node.FieldOsInfo] = struct{}{}
}

// OsInfoCleared returns if the "os_info" field was cleared in this mutation.
func (m *NodeMutation) OsInfoCleared() bool {
	_, ok := m.clearedFields[node.FieldOsInfo]
	return ok
}

// ResetOsInfo resets all changes to the "os_info" field.
func (m *NodeMutation) ResetOsInfo() {
	m.os_info = nil
	delete(m.clearedFields, node.FieldOsInfo)
}

// SetAgentInfo sets the "agent_info" field.
func (m *NodeMutation) SetAgentInfo(mi *models.AgentInfo) {
	m.agent_info = &mi
}

// AgentInfo returns the value of the "agent_info" field in the mutation.
func (m *NodeMutation) AgentInfo() (r *models.AgentInfo, exists bool) {
	v := m.agent_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentInfo returns the old "agent_info" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldAgentInfo(ctx context.Context) (v *models.AgentInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentInfo: %w", err)
	}
	return oldValue.AgentInfo, nil
}

// ClearAgentInfo clears the value of the "agent_info" field.
func (m *NodeMutation) ClearAgentInfo() {
	m.agent_info = nil
	m.clearedFields[node.FieldAgentInfo] = struct{}{}
}

// AgentInfoCleared returns if the "agent_info" field was cleared in this mutation.
func (m *NodeMutation) AgentInfoCleared() bool {
	_, ok := m.clearedFields[node.FieldAgentInfo]
	return ok
}

// ResetAgentInfo resets all changes to the "agent_info" field.
func (m *NodeMutation) ResetAgentInfo() {
	m.agent_info = nil
	delete(m.clearedFields, node.FieldAgentInfo)
}

// SetTags sets the "tags" field.
func (m *NodeMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NodeMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NodeMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NodeMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NodeMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[node.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NodeMutation) TagsCleared() bool {
	_, ok := m.clearedFields[node.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NodeMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, node.FieldTags)
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *NodeMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *NodeMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *NodeMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[node.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *NodeMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[node.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *NodeMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, node.FieldLastSeen)
}

// AddServiceInstanceIDs adds the "service_instances" edge to the ServiceInstance entity by ids.
func (m *NodeMutation) AddServiceInstanceIDs(ids ...string) {
	if m.service_instances == nil {
		m.service_instances = make(map[string]struct{})
	}
	for i := range ids {
		m.service_instances[ids[i]] = struct{}{}
	}
}

// ClearServiceInstances clears the "service_instances" edge to the ServiceInstance entity.
func (m *NodeMutation) ClearServiceInstances() {
	m.clearedservice_instances = true
}

// ServiceInstancesCleared reports if the "service_instances" edge to the ServiceInstance entity was cleared.
func (m *NodeMutation) ServiceInstancesCleared() bool {
	return m.clearedservice_instances
}

// RemoveServiceInstanceIDs removes the "service_instances" edge to the ServiceInstance entity by IDs.
func (m *NodeMutation) RemoveServiceInstanceIDs(ids ...string) {
	if m.removedservice_instances == nil {
		m.removedservice_instances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_instances, ids[i])
		m.removedservice_instances[ids[i]] = struct{}{}
	}
}

// RemovedServiceInstances returns the removed IDs of the "service_instances" edge to the ServiceInstance entity.
func (m *NodeMutation) RemovedServiceInstancesIDs() (ids []string) {
	for id := range m.removedservice_instances {
		ids = append(ids, id)
	}
	return
}

// ServiceInstancesIDs returns the "service_instances" edge IDs in the mutation.
func (m *NodeMutation) ServiceInstancesIDs() (ids []string) {
	for id := range m.service_instances {
		ids = append(ids, id)
	}
	return
}

// ResetServiceInstances resets all changes to the "service_instances" edge.
func (m *NodeMutation) ResetServiceInstances() {
	m.service_instances = nil
	m.clearedservice_instances = false
	m.removedservice_instances = nil
}

// AddAgentTokenIDs adds the "agent_tokens" edge to the AgentToken entity by ids.
func (m *NodeMutation) AddAgentTokenIDs(ids ...string) {
	if m.agent_tokens == nil {
		m.agent_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.agent_tokens[ids[i]] = struct{}{}
	}
}

// ClearAgentTokens clears the "agent_tokens" edge to the AgentToken entity.
func (m *NodeMutation) ClearAgentTokens() {
	m.clearedagent_tokens = true
}

// AgentTokensCleared reports if the "agent_tokens" edge to the AgentToken entity was cleared.
func (m *NodeMutation) AgentTokensCleared() bool {
	return m.clearedagent_tokens
}

// RemoveAgentTokenIDs removes the "agent_tokens" edge to the AgentToken entity by IDs.
func (m *NodeMutation) RemoveAgentTokenIDs(ids ...string) {
	if m.removedagent_tokens == nil {
		m.removedagent_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agent_tokens, ids[i])
		m.removedagent_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAgentTokens returns the removed IDs of the "agent_tokens" edge to the AgentToken entity.
func (m *NodeMutation) RemovedAgentTokensIDs() (ids []string) {
	for id := range m.removedagent_tokens {
		ids = append(ids, id)
	}
	return
}

// AgentTokensIDs returns the "agent_tokens" edge IDs in the mutation.
func (m *NodeMutation) AgentTokensIDs() (ids []string) {
	for id := range m.agent_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAgentTokens resets all changes to the "agent_tokens" edge.
func (m *NodeMutation) ResetAgentTokens() {
	m.agent_tokens = nil
	m.clearedagent_tokens = false
	m.removedagent_tokens = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m.description != nil {
		fields = append(fields, node.FieldDescription)
	}
	if m.hostname != nil {
		fields = append(fields, node.FieldHostname)
	}
	if m.ip_address != nil {
		fields = append(fields, node.FieldIPAddress)
	}
	if m.port != nil {
		fields = append(fields, node.FieldPort)
	}
	if m.status != nil {
		fields = append(fields, node.FieldStatus)
	}
	if m.os_info != nil {
		fields = append(fields, node.FieldOsInfo)
	}
	if m.agent_info != nil {
		fields = append(fields, node.FieldAgentInfo)
	}
	if m.tags != nil {
		fields = append(fields, node.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	if m.last_seen != nil {
		fields = append(fields, node.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldName:
		return m.Name()
	case node.FieldDescription:
		return m.Description()
	case node.FieldHostname:
		return m.Hostname()
	case node.FieldIPAddress:
		return m.IPAddress()
	case node.FieldPort:
		return m.Port()
	case node.FieldStatus:
		return m.Status()
	case node.FieldOsInfo:
		return m.OsInfo()
	case node.FieldAgentInfo:
		return m.AgentInfo()
	case node.FieldTags:
		return m.Tags()
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	case node.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldDescription:
		return m.OldDescription(ctx)
	case node.FieldHostname:
		return m.OldHostname(ctx)
	case node.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case node.FieldPort:
		return m.OldPort(ctx)
	case node.FieldStatus:
		return m.OldStatus(ctx)
	case node.FieldOsInfo:
		return m.OldOsInfo(ctx)
	case node.FieldAgentInfo:
		return m.OldAgentInfo(ctx)
	case node.FieldTags:
		return m.OldTags(ctx)
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case node.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case node.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case node.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case node.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case node.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case node.FieldOsInfo:
		v, ok := value.(*models.OSInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsInfo(v)
		return nil
	case node.FieldAgentInfo:
		v, ok := value.(*models.AgentInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentInfo(v)
		return nil
	case node.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case node.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, node.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldDescription) {
		fields = append(fields, node.FieldDescription)
	}
	if m.FieldCleared(node.FieldOsInfo) {
		fields = append(fields, node.FieldOsInfo)
	}
	if m.FieldCleared(node.FieldAgentInfo) {
		fields = append(fields, node.FieldAgentInfo)
	}
	if m.FieldCleared(node.FieldTags) {
		fields = append(fields, node.FieldTags)
	}
	if m.FieldCleared(node.FieldLastSeen) {
		fields = append(fields, node.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldDescription:
		m.ClearDescription()
		return nil
	case node.FieldOsInfo:
		m.ClearOsInfo()
		return nil
	case node.FieldAgentInfo:
		m.ClearAgentInfo()
		return nil
	case node.FieldTags:
		m.ClearTags()
		return nil
	case node.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldDescription:
		m.ResetDescription()
		return nil
	case node.FieldHostname:
		m.ResetHostname()
		return nil
	case node.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case node.FieldPort:
		m.ResetPort()
		return nil
	case node.FieldStatus:
		m.ResetStatus()
		return nil
	case node.FieldOsInfo:
		m.ResetOsInfo()
		return nil
	case node.FieldAgentInfo:
		m.ResetAgentInfo()
		return nil
	case node.FieldTags:
		m.ResetTags()
		return nil
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case node.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service_instances != nil {
		edges = append(edges, node.EdgeServiceInstances)
	}
	if m.agent_tokens != nil {
		edges = append(edges, node.EdgeAgentTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.service_instances))
		for id := range m.service_instances {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeAgentTokens:
		ids := make([]ent.Value, 0, len(m.agent_tokens))
		for id := range m.agent_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedservice_instances != nil {
		edges = append(edges, node.EdgeServiceInstances)
	}
	if m.removedagent_tokens != nil {
		edges = append(edges, node.EdgeAgentTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeServiceInstances:
		ids := make([]ent.Value, 0, len(m.removedservice_instances))
		for id := range m.removedservice_instances {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeAgentTokens:
		ids := make([]ent.Value, 0, len(m.removedagent_tokens))
		for id := range m.removedagent_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice_instances {
		edges = append(edges, node.EdgeServiceInstances)
	}
	if m.clearedagent_tokens {
		edges = append(edges, node.EdgeAgentTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeServiceInstances:
		return m.clearedservice_instances
	case node.EdgeAgentTokens:
		return m.clearedagent_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeServiceInstances:
		m.ResetServiceInstances()
		return nil
	case node.EdgeAgentTokens:
		m.ResetAgentTokens()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// ServiceInstanceMutation represents an operation that mutates the ServiceInstance nodes in the graph.
type ServiceInstanceMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	service_type  *string
	status        *string
	port          *int
	addport       *int
	protocol      *string
	_config       *map[string]interface{}
	tags          *[]string
	appendtags    []string
	created_at    *time.Time
	updated_at    *time.Time
	last_seen     *time.Time
	clearedFields map[string]struct{}
	node          *string
	clearednode   bool
	done          bool
	oldValue      func(context.Context) (*ServiceInstance, error)
	predicates    []predicate.ServiceInstance
}

var _ ent.Mutation = (*ServiceInstanceMutation)(nil)

// serviceinstanceOption allows management of the mutation configuration using functional options.
type serviceinstanceOption func(*ServiceInstanceMutation)

// newServiceInstanceMutation creates new mutation for the ServiceInstance entity.
func newServiceInstanceMutation(c config, op Op, opts ...serviceinstanceOption) *ServiceInstanceMutation {
	m := &ServiceInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceInstanceID sets the ID field of the mutation.
func withServiceInstanceID(id string) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceInstance
		)
		m.oldValue = func(ctx context.Context) (*ServiceInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceInstance sets the old ServiceInstance of the mutation.
func withServiceInstance(node *ServiceInstance) serviceinstanceOption {
	return func(m *ServiceInstanceMutation) {
		m.oldValue = func(context.Context) (*ServiceInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceInstance entities.
func (m *ServiceInstanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceInstanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceInstanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *ServiceInstanceMutation) SetNodeID(s string) {
	m.node = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *ServiceInstanceMutation) NodeID() (r string, exists bool) {
	v := m.node
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *ServiceInstanceMutation) ResetNodeID() {
	m.node = nil
}

// SetName sets the "name" field.
func (m *ServiceInstanceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceInstanceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceInstanceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceInstanceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceInstanceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceInstanceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[serviceinstance.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceInstanceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceInstanceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, serviceinstance.FieldDescription)
}

// SetServiceType sets the "service_type" field.
func (m *ServiceInstanceMutation) SetServiceType(s string) {
	m.service_type = &s
}

// ServiceType returns the value of the "service_type" field in the mutation.
func (m *ServiceInstanceMutation) ServiceType() (r string, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old "service_type" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldServiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType resets all changes to the "service_type" field.
func (m *ServiceInstanceMutation) ResetServiceType() {
	m.service_type = nil
}

// SetStatus sets the "status" field.
func (m *ServiceInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetPort sets the "port" field.
func (m *ServiceInstanceMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ServiceInstanceMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *ServiceInstanceMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ServiceInstanceMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *ServiceInstanceMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetProtocol sets the "protocol" field.
func (m *ServiceInstanceMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *ServiceInstanceMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *ServiceInstanceMutation) ResetProtocol() {
	m.protocol = nil
}

// SetConfig sets the "config" field.
func (m *ServiceInstanceMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ServiceInstanceMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ServiceInstanceMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[serviceinstance.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ServiceInstanceMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ServiceInstanceMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, serviceinstance.FieldConfig)
}

// SetTags sets the "tags" field.
func (m *ServiceInstanceMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ServiceInstanceMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ServiceInstanceMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ServiceInstanceMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ServiceInstanceMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[serviceinstance.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ServiceInstanceMutation) TagsCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ServiceInstanceMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, serviceinstance.FieldTags)
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *ServiceInstanceMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *ServiceInstanceMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the ServiceInstance entity.
// If the ServiceInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceInstanceMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *ServiceInstanceMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[serviceinstance.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *ServiceInstanceMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[serviceinstance.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *ServiceInstanceMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, serviceinstance.FieldLastSeen)
}

// ClearNode clears the "node" edge to the Node entity.
func (m *ServiceInstanceMutation) ClearNode() {
	m.clearednode = true
	m.clearedFields[serviceinstance.FieldNodeID] = struct{}{}
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *ServiceInstanceMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *ServiceInstanceMutation) NodeIDs() (ids []string) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *ServiceInstanceMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the ServiceInstanceMutation builder.
func (m *ServiceInstanceMutation) Where(ps ...predicate.ServiceInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceInstance).
func (m *ServiceInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceInstanceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.node != nil {
		fields = append(fields, serviceinstance.FieldNodeID)
	}
	if m.name != nil {
		fields = append(fields, serviceinstance.FieldName)
	}
	if m.description != nil {
		fields = append(fields, serviceinstance.FieldDescription)
	}
	if m.service_type != nil {
		fields = append(fields, serviceinstance.FieldServiceType)
	}
	if m.status != nil {
		fields = append(fields, serviceinstance.FieldStatus)
	}
	if m.port != nil {
		fields = append(fields, serviceinstance.FieldPort)
	}
	if m.protocol != nil {
		fields = append(fields, serviceinstance.FieldProtocol)
	}
	if m._config != nil {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, serviceinstance.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, serviceinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, serviceinstance.FieldUpdatedAt)
	}
	if m.last_seen != nil {
		fields = append(fields, serviceinstance.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldNodeID:
		return m.NodeID()
	case serviceinstance.FieldName:
		return m.Name()
	case serviceinstance.FieldDescription:
		return m.Description()
	case serviceinstance.FieldServiceType:
		return m.ServiceType()
	case serviceinstance.FieldStatus:
		return m.Status()
	case serviceinstance.FieldPort:
		return m.Port()
	case serviceinstance.FieldProtocol:
		return m.Protocol()
	case serviceinstance.FieldConfig:
		return m.Config()
	case serviceinstance.FieldTags:
		return m.Tags()
	case serviceinstance.FieldCreatedAt:
		return m.CreatedAt()
	case serviceinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case serviceinstance.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceinstance.FieldNodeID:
		return m.OldNodeID(ctx)
	case serviceinstance.FieldName:
		return m.OldName(ctx)
	case serviceinstance.FieldDescription:
		return m.OldDescription(ctx)
	case serviceinstance.FieldServiceType:
		return m.OldServiceType(ctx)
	case serviceinstance.FieldStatus:
		return m.OldStatus(ctx)
	case serviceinstance.FieldPort:
		return m.OldPort(ctx)
	case serviceinstance.FieldProtocol:
		return m.OldProtocol(ctx)
	case serviceinstance.FieldConfig:
		return m.OldConfig(ctx)
	case serviceinstance.FieldTags:
		return m.OldTags(ctx)
	case serviceinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case serviceinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case serviceinstance.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case serviceinstance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case serviceinstance.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case serviceinstance.FieldServiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case serviceinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case serviceinstance.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case serviceinstance.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case serviceinstance.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case serviceinstance.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case serviceinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case serviceinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case serviceinstance.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, serviceinstance.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceinstance.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceinstance.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceinstance.FieldDescription) {
		fields = append(fields, serviceinstance.FieldDescription)
	}
	if m.FieldCleared(serviceinstance.FieldConfig) {
		fields = append(fields, serviceinstance.FieldConfig)
	}
	if m.FieldCleared(serviceinstance.FieldTags) {
		fields = append(fields, serviceinstance.FieldTags)
	}
	if m.FieldCleared(serviceinstance.FieldLastSeen) {
		fields = append(fields, serviceinstance.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ClearField(name string) error {
	switch name {
	case serviceinstance.FieldDescription:
		m.ClearDescription()
		return nil
	case serviceinstance.FieldConfig:
		m.ClearConfig()
		return nil
	case serviceinstance.FieldTags:
		m.ClearTags()
		return nil
	case serviceinstance.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceInstanceMutation) ResetField(name string) error {
	switch name {
	case serviceinstance.FieldNodeID:
		m.ResetNodeID()
		return nil
	case serviceinstance.FieldName:
		m.ResetName()
		return nil
	case serviceinstance.FieldDescription:
		m.ResetDescription()
		return nil
	case serviceinstance.FieldServiceType:
		m.ResetServiceType()
		return nil
	case serviceinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case serviceinstance.FieldPort:
		m.ResetPort()
		return nil
	case serviceinstance.FieldProtocol:
		m.ResetProtocol()
		return nil
	case serviceinstance.FieldConfig:
		m.ResetConfig()
		return nil
	case serviceinstance.FieldTags:
		m.ResetTags()
		return nil
	case serviceinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case serviceinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case serviceinstance.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.node != nil {
		edges = append(edges, serviceinstance.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceinstance.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednode {
		edges = append(edges, serviceinstance.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceinstance.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceInstanceMutation) ClearEdge(name string) error {
	switch name {
	case serviceinstance.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceInstanceMutation) ResetEdge(name string) error {
	switch name {
	case serviceinstance.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown ServiceInstance edge %s", name)
}

// SingBoxConfigMutation represents an operation that mutates the SingBoxConfig nodes in the graph.
type SingBoxConfigMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	description         *string
	created_at          *time.Time
	updated_at          *time.Time
	log_config          **models.SingBoxLogConfig
	dns_config          **models.SingBoxDNSConfig
	ntp_config          **models.SingBoxNTPConfig
	inbounds            *[]interface{}
	appendinbounds      []interface{}
	outbounds           *[]interface{}
	appendoutbounds     []interface{}
	route_config        **models.SingBoxRouteConfig
	experimental_config *map[string]interface{}
	endpoints           *[]interface{}
	appendendpoints     []interface{}
	certificate_config  *map[string]interface{}
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*SingBoxConfig, error)
	predicates          []predicate.SingBoxConfig
}

var _ ent.Mutation = (*SingBoxConfigMutation)(nil)

// singboxconfigOption allows management of the mutation configuration using functional options.
type singboxconfigOption func(*SingBoxConfigMutation)

// newSingBoxConfigMutation creates new mutation for the SingBoxConfig entity.
func newSingBoxConfigMutation(c config, op Op, opts ...singboxconfigOption) *SingBoxConfigMutation {
	m := &SingBoxConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeSingBoxConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSingBoxConfigID sets the ID field of the mutation.
func withSingBoxConfigID(id string) singboxconfigOption {
	return func(m *SingBoxConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *SingBoxConfig
		)
		m.oldValue = func(ctx context.Context) (*SingBoxConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SingBoxConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSingBoxConfig sets the old SingBoxConfig of the mutation.
func withSingBoxConfig(node *SingBoxConfig) singboxconfigOption {
	return func(m *SingBoxConfigMutation) {
		m.oldValue = func(context.Context) (*SingBoxConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SingBoxConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SingBoxConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SingBoxConfig entities.
func (m *SingBoxConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SingBoxConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SingBoxConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SingBoxConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SingBoxConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SingBoxConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SingBoxConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SingBoxConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SingBoxConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SingBoxConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[singboxconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SingBoxConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SingBoxConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, singboxconfig.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *SingBoxConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SingBoxConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SingBoxConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SingBoxConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SingBoxConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SingBoxConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLogConfig sets the "log_config" field.
func (m *SingBoxConfigMutation) SetLogConfig(mblc *models.SingBoxLogConfig) {
	m.log_config = &mblc
}

// LogConfig returns the value of the "log_config" field in the mutation.
func (m *SingBoxConfigMutation) LogConfig() (r *models.SingBoxLogConfig, exists bool) {
	v := m.log_config
	if v == nil {
		return
	}
	return *v, true
}

// OldLogConfig returns the old "log_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldLogConfig(ctx context.Context) (v *models.SingBoxLogConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogConfig: %w", err)
	}
	return oldValue.LogConfig, nil
}

// ClearLogConfig clears the value of the "log_config" field.
func (m *SingBoxConfigMutation) ClearLogConfig() {
	m.log_config = nil
	m.clearedFields[singboxconfig.FieldLogConfig] = struct{}{}
}

// LogConfigCleared returns if the "log_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) LogConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldLogConfig]
	return ok
}

// ResetLogConfig resets all changes to the "log_config" field.
func (m *SingBoxConfigMutation) ResetLogConfig() {
	m.log_config = nil
	delete(m.clearedFields, singboxconfig.FieldLogConfig)
}

// SetDNSConfig sets the "dns_config" field.
func (m *SingBoxConfigMutation) SetDNSConfig(mbdc *models.SingBoxDNSConfig) {
	m.dns_config = &mbdc
}

// DNSConfig returns the value of the "dns_config" field in the mutation.
func (m *SingBoxConfigMutation) DNSConfig() (r *models.SingBoxDNSConfig, exists bool) {
	v := m.dns_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSConfig returns the old "dns_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldDNSConfig(ctx context.Context) (v *models.SingBoxDNSConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSConfig: %w", err)
	}
	return oldValue.DNSConfig, nil
}

// ClearDNSConfig clears the value of the "dns_config" field.
func (m *SingBoxConfigMutation) ClearDNSConfig() {
	m.dns_config = nil
	m.clearedFields[singboxconfig.FieldDNSConfig] = struct{}{}
}

// DNSConfigCleared returns if the "dns_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) DNSConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldDNSConfig]
	return ok
}

// ResetDNSConfig resets all changes to the "dns_config" field.
func (m *SingBoxConfigMutation) ResetDNSConfig() {
	m.dns_config = nil
	delete(m.clearedFields, singboxconfig.FieldDNSConfig)
}

// SetNtpConfig sets the "ntp_config" field.
func (m *SingBoxConfigMutation) SetNtpConfig(mbnc *models.SingBoxNTPConfig) {
	m.ntp_config = &mbnc
}

// NtpConfig returns the value of the "ntp_config" field in the mutation.
func (m *SingBoxConfigMutation) NtpConfig() (r *models.SingBoxNTPConfig, exists bool) {
	v := m.ntp_config
	if v == nil {
		return
	}
	return *v, true
}

// OldNtpConfig returns the old "ntp_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldNtpConfig(ctx context.Context) (v *models.SingBoxNTPConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNtpConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNtpConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtpConfig: %w", err)
	}
	return oldValue.NtpConfig, nil
}

// ClearNtpConfig clears the value of the "ntp_config" field.
func (m *SingBoxConfigMutation) ClearNtpConfig() {
	m.ntp_config = nil
	m.clearedFields[singboxconfig.FieldNtpConfig] = struct{}{}
}

// NtpConfigCleared returns if the "ntp_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) NtpConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldNtpConfig]
	return ok
}

// ResetNtpConfig resets all changes to the "ntp_config" field.
func (m *SingBoxConfigMutation) ResetNtpConfig() {
	m.ntp_config = nil
	delete(m.clearedFields, singboxconfig.FieldNtpConfig)
}

// SetInbounds sets the "inbounds" field.
func (m *SingBoxConfigMutation) SetInbounds(i []interface{}) {
	m.inbounds = &i
	m.appendinbounds = nil
}

// Inbounds returns the value of the "inbounds" field in the mutation.
func (m *SingBoxConfigMutation) Inbounds() (r []interface{}, exists bool) {
	v := m.inbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldInbounds returns the old "inbounds" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldInbounds(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInbounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInbounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInbounds: %w", err)
	}
	return oldValue.Inbounds, nil
}

// AppendInbounds adds i to the "inbounds" field.
func (m *SingBoxConfigMutation) AppendInbounds(i []interface{}) {
	m.appendinbounds = append(m.appendinbounds, i...)
}

// AppendedInbounds returns the list of values that were appended to the "inbounds" field in this mutation.
func (m *SingBoxConfigMutation) AppendedInbounds() ([]interface{}, bool) {
	if len(m.appendinbounds) == 0 {
		return nil, false
	}
	return m.appendinbounds, true
}

// ClearInbounds clears the value of the "inbounds" field.
func (m *SingBoxConfigMutation) ClearInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	m.clearedFields[singboxconfig.FieldInbounds] = struct{}{}
}

// InboundsCleared returns if the "inbounds" field was cleared in this mutation.
func (m *SingBoxConfigMutation) InboundsCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldInbounds]
	return ok
}

// ResetInbounds resets all changes to the "inbounds" field.
func (m *SingBoxConfigMutation) ResetInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	delete(m.clearedFields, singboxconfig.FieldInbounds)
}

// SetOutbounds sets the "outbounds" field.
func (m *SingBoxConfigMutation) SetOutbounds(i []interface{}) {
	m.outbounds = &i
	m.appendoutbounds = nil
}

// Outbounds returns the value of the "outbounds" field in the mutation.
func (m *SingBoxConfigMutation) Outbounds() (r []interface{}, exists bool) {
	v := m.outbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldOutbounds returns the old "outbounds" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldOutbounds(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutbounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutbounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutbounds: %w", err)
	}
	return oldValue.Outbounds, nil
}

// AppendOutbounds adds i to the "outbounds" field.
func (m *SingBoxConfigMutation) AppendOutbounds(i []interface{}) {
	m.appendoutbounds = append(m.appendoutbounds, i...)
}

// AppendedOutbounds returns the list of values that were appended to the "outbounds" field in this mutation.
func (m *SingBoxConfigMutation) AppendedOutbounds() ([]interface{}, bool) {
	if len(m.appendoutbounds) == 0 {
		return nil, false
	}
	return m.appendoutbounds, true
}

// ClearOutbounds clears the value of the "outbounds" field.
func (m *SingBoxConfigMutation) ClearOutbounds() {
	m.outbounds = nil
	m.appendoutbounds = nil
	m.clearedFields[singboxconfig.FieldOutbounds] = struct{}{}
}

// OutboundsCleared returns if the "outbounds" field was cleared in this mutation.
func (m *SingBoxConfigMutation) OutboundsCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldOutbounds]
	return ok
}

// ResetOutbounds resets all changes to the "outbounds" field.
func (m *SingBoxConfigMutation) ResetOutbounds() {
	m.outbounds = nil
	m.appendoutbounds = nil
	delete(m.clearedFields, singboxconfig.FieldOutbounds)
}

// SetRouteConfig sets the "route_config" field.
func (m *SingBoxConfigMutation) SetRouteConfig(mbrc *models.SingBoxRouteConfig) {
	m.route_config = &mbrc
}

// RouteConfig returns the value of the "route_config" field in the mutation.
func (m *SingBoxConfigMutation) RouteConfig() (r *models.SingBoxRouteConfig, exists bool) {
	v := m.route_config
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteConfig returns the old "route_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldRouteConfig(ctx context.Context) (v *models.SingBoxRouteConfig, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteConfig: %w", err)
	}
	return oldValue.RouteConfig, nil
}

// ClearRouteConfig clears the value of the "route_config" field.
func (m *SingBoxConfigMutation) ClearRouteConfig() {
	m.route_config = nil
	m.clearedFields[singboxconfig.FieldRouteConfig] = struct{}{}
}

// RouteConfigCleared returns if the "route_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) RouteConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldRouteConfig]
	return ok
}

// ResetRouteConfig resets all changes to the "route_config" field.
func (m *SingBoxConfigMutation) ResetRouteConfig() {
	m.route_config = nil
	delete(m.clearedFields, singboxconfig.FieldRouteConfig)
}

// SetExperimentalConfig sets the "experimental_config" field.
func (m *SingBoxConfigMutation) SetExperimentalConfig(value map[string]interface{}) {
	m.experimental_config = &value
}

// ExperimentalConfig returns the value of the "experimental_config" field in the mutation.
func (m *SingBoxConfigMutation) ExperimentalConfig() (r map[string]interface{}, exists bool) {
	v := m.experimental_config
	if v == nil {
		return
	}
	return *v, true
}

// OldExperimentalConfig returns the old "experimental_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldExperimentalConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperimentalConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperimentalConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperimentalConfig: %w", err)
	}
	return oldValue.ExperimentalConfig, nil
}

// ClearExperimentalConfig clears the value of the "experimental_config" field.
func (m *SingBoxConfigMutation) ClearExperimentalConfig() {
	m.experimental_config = nil
	m.clearedFields[singboxconfig.FieldExperimentalConfig] = struct{}{}
}

// ExperimentalConfigCleared returns if the "experimental_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) ExperimentalConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldExperimentalConfig]
	return ok
}

// ResetExperimentalConfig resets all changes to the "experimental_config" field.
func (m *SingBoxConfigMutation) ResetExperimentalConfig() {
	m.experimental_config = nil
	delete(m.clearedFields, singboxconfig.FieldExperimentalConfig)
}

// SetEndpoints sets the "endpoints" field.
func (m *SingBoxConfigMutation) SetEndpoints(i []interface{}) {
	m.endpoints = &i
	m.appendendpoints = nil
}

// Endpoints returns the value of the "endpoints" field in the mutation.
func (m *SingBoxConfigMutation) Endpoints() (r []interface{}, exists bool) {
	v := m.endpoints
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoints returns the old "endpoints" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldEndpoints(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoints: %w", err)
	}
	return oldValue.Endpoints, nil
}

// AppendEndpoints adds i to the "endpoints" field.
func (m *SingBoxConfigMutation) AppendEndpoints(i []interface{}) {
	m.appendendpoints = append(m.appendendpoints, i...)
}

// AppendedEndpoints returns the list of values that were appended to the "endpoints" field in this mutation.
func (m *SingBoxConfigMutation) AppendedEndpoints() ([]interface{}, bool) {
	if len(m.appendendpoints) == 0 {
		return nil, false
	}
	return m.appendendpoints, true
}

// ClearEndpoints clears the value of the "endpoints" field.
func (m *SingBoxConfigMutation) ClearEndpoints() {
	m.endpoints = nil
	m.appendendpoints = nil
	m.clearedFields[singboxconfig.FieldEndpoints] = struct{}{}
}

// EndpointsCleared returns if the "endpoints" field was cleared in this mutation.
func (m *SingBoxConfigMutation) EndpointsCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldEndpoints]
	return ok
}

// ResetEndpoints resets all changes to the "endpoints" field.
func (m *SingBoxConfigMutation) ResetEndpoints() {
	m.endpoints = nil
	m.appendendpoints = nil
	delete(m.clearedFields, singboxconfig.FieldEndpoints)
}

// SetCertificateConfig sets the "certificate_config" field.
func (m *SingBoxConfigMutation) SetCertificateConfig(value map[string]interface{}) {
	m.certificate_config = &value
}

// CertificateConfig returns the value of the "certificate_config" field in the mutation.
func (m *SingBoxConfigMutation) CertificateConfig() (r map[string]interface{}, exists bool) {
	v := m.certificate_config
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateConfig returns the old "certificate_config" field's value of the SingBoxConfig entity.
// If the SingBoxConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SingBoxConfigMutation) OldCertificateConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateConfig: %w", err)
	}
	return oldValue.CertificateConfig, nil
}

// ClearCertificateConfig clears the value of the "certificate_config" field.
func (m *SingBoxConfigMutation) ClearCertificateConfig() {
	m.certificate_config = nil
	m.clearedFields[singboxconfig.FieldCertificateConfig] = struct{}{}
}

// CertificateConfigCleared returns if the "certificate_config" field was cleared in this mutation.
func (m *SingBoxConfigMutation) CertificateConfigCleared() bool {
	_, ok := m.clearedFields[singboxconfig.FieldCertificateConfig]
	return ok
}

// ResetCertificateConfig resets all changes to the "certificate_config" field.
func (m *SingBoxConfigMutation) ResetCertificateConfig() {
	m.certificate_config = nil
	delete(m.clearedFields, singboxconfig.FieldCertificateConfig)
}

// Where appends a list predicates to the SingBoxConfigMutation builder.
func (m *SingBoxConfigMutation) Where(ps ...predicate.SingBoxConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SingBoxConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SingBoxConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SingBoxConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SingBoxConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SingBoxConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SingBoxConfig).
func (m *SingBoxConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SingBoxConfigMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, singboxconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, singboxconfig.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, singboxconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, singboxconfig.FieldUpdatedAt)
	}
	if m.log_config != nil {
		fields = append(fields, singboxconfig.FieldLogConfig)
	}
	if m.dns_config != nil {
		fields = append(fields, singboxconfig.FieldDNSConfig)
	}
	if m.ntp_config != nil {
		fields = append(fields, singboxconfig.FieldNtpConfig)
	}
	if m.inbounds != nil {
		fields = append(fields, singboxconfig.FieldInbounds)
	}
	if m.outbounds != nil {
		fields = append(fields, singboxconfig.FieldOutbounds)
	}
	if m.route_config != nil {
		fields = append(fields, singboxconfig.FieldRouteConfig)
	}
	if m.experimental_config != nil {
		fields = append(fields, singboxconfig.FieldExperimentalConfig)
	}
	if m.endpoints != nil {
		fields = append(fields, singboxconfig.FieldEndpoints)
	}
	if m.certificate_config != nil {
		fields = append(fields, singboxconfig.FieldCertificateConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SingBoxConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case singboxconfig.FieldName:
		return m.Name()
	case singboxconfig.FieldDescription:
		return m.Description()
	case singboxconfig.FieldCreatedAt:
		return m.CreatedAt()
	case singboxconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case singboxconfig.FieldLogConfig:
		return m.LogConfig()
	case singboxconfig.FieldDNSConfig:
		return m.DNSConfig()
	case singboxconfig.FieldNtpConfig:
		return m.NtpConfig()
	case singboxconfig.FieldInbounds:
		return m.Inbounds()
	case singboxconfig.FieldOutbounds:
		return m.Outbounds()
	case singboxconfig.FieldRouteConfig:
		return m.RouteConfig()
	case singboxconfig.FieldExperimentalConfig:
		return m.ExperimentalConfig()
	case singboxconfig.FieldEndpoints:
		return m.Endpoints()
	case singboxconfig.FieldCertificateConfig:
		return m.CertificateConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SingBoxConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case singboxconfig.FieldName:
		return m.OldName(ctx)
	case singboxconfig.FieldDescription:
		return m.OldDescription(ctx)
	case singboxconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case singboxconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case singboxconfig.FieldLogConfig:
		return m.OldLogConfig(ctx)
	case singboxconfig.FieldDNSConfig:
		return m.OldDNSConfig(ctx)
	case singboxconfig.FieldNtpConfig:
		return m.OldNtpConfig(ctx)
	case singboxconfig.FieldInbounds:
		return m.OldInbounds(ctx)
	case singboxconfig.FieldOutbounds:
		return m.OldOutbounds(ctx)
	case singboxconfig.FieldRouteConfig:
		return m.OldRouteConfig(ctx)
	case singboxconfig.FieldExperimentalConfig:
		return m.OldExperimentalConfig(ctx)
	case singboxconfig.FieldEndpoints:
		return m.OldEndpoints(ctx)
	case singboxconfig.FieldCertificateConfig:
		return m.OldCertificateConfig(ctx)
	}
	return nil, fmt.Errorf("unknown SingBoxConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SingBoxConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case singboxconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case singboxconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case singboxconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case singboxconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case singboxconfig.FieldLogConfig:
		v, ok := value.(*models.SingBoxLogConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogConfig(v)
		return nil
	case singboxconfig.FieldDNSConfig:
		v, ok := value.(*models.SingBoxDNSConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSConfig(v)
		return nil
	case singboxconfig.FieldNtpConfig:
		v, ok := value.(*models.SingBoxNTPConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtpConfig(v)
		return nil
	case singboxconfig.FieldInbounds:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInbounds(v)
		return nil
	case singboxconfig.FieldOutbounds:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutbounds(v)
		return nil
	case singboxconfig.FieldRouteConfig:
		v, ok := value.(*models.SingBoxRouteConfig)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteConfig(v)
		return nil
	case singboxconfig.FieldExperimentalConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperimentalConfig(v)
		return nil
	case singboxconfig.FieldEndpoints:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoints(v)
		return nil
	case singboxconfig.FieldCertificateConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateConfig(v)
		return nil
	}
	return fmt.Errorf("unknown SingBoxConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SingBoxConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SingBoxConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SingBoxConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SingBoxConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SingBoxConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(singboxconfig.FieldDescription) {
		fields = append(fields, singboxconfig.FieldDescription)
	}
	if m.FieldCleared(singboxconfig.FieldLogConfig) {
		fields = append(fields, singboxconfig.FieldLogConfig)
	}
	if m.FieldCleared(singboxconfig.FieldDNSConfig) {
		fields = append(fields, singboxconfig.FieldDNSConfig)
	}
	if m.FieldCleared(singboxconfig.FieldNtpConfig) {
		fields = append(fields, singboxconfig.FieldNtpConfig)
	}
	if m.FieldCleared(singboxconfig.FieldInbounds) {
		fields = append(fields, singboxconfig.FieldInbounds)
	}
	if m.FieldCleared(singboxconfig.FieldOutbounds) {
		fields = append(fields, singboxconfig.FieldOutbounds)
	}
	if m.FieldCleared(singboxconfig.FieldRouteConfig) {
		fields = append(fields, singboxconfig.FieldRouteConfig)
	}
	if m.FieldCleared(singboxconfig.FieldExperimentalConfig) {
		fields = append(fields, singboxconfig.FieldExperimentalConfig)
	}
	if m.FieldCleared(singboxconfig.FieldEndpoints) {
		fields = append(fields, singboxconfig.FieldEndpoints)
	}
	if m.FieldCleared(singboxconfig.FieldCertificateConfig) {
		fields = append(fields, singboxconfig.FieldCertificateConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SingBoxConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SingBoxConfigMutation) ClearField(name string) error {
	switch name {
	case singboxconfig.FieldDescription:
		m.ClearDescription()
		return nil
	case singboxconfig.FieldLogConfig:
		m.ClearLogConfig()
		return nil
	case singboxconfig.FieldDNSConfig:
		m.ClearDNSConfig()
		return nil
	case singboxconfig.FieldNtpConfig:
		m.ClearNtpConfig()
		return nil
	case singboxconfig.FieldInbounds:
		m.ClearInbounds()
		return nil
	case singboxconfig.FieldOutbounds:
		m.ClearOutbounds()
		return nil
	case singboxconfig.FieldRouteConfig:
		m.ClearRouteConfig()
		return nil
	case singboxconfig.FieldExperimentalConfig:
		m.ClearExperimentalConfig()
		return nil
	case singboxconfig.FieldEndpoints:
		m.ClearEndpoints()
		return nil
	case singboxconfig.FieldCertificateConfig:
		m.ClearCertificateConfig()
		return nil
	}
	return fmt.Errorf("unknown SingBoxConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SingBoxConfigMutation) ResetField(name string) error {
	switch name {
	case singboxconfig.FieldName:
		m.ResetName()
		return nil
	case singboxconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case singboxconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case singboxconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case singboxconfig.FieldLogConfig:
		m.ResetLogConfig()
		return nil
	case singboxconfig.FieldDNSConfig:
		m.ResetDNSConfig()
		return nil
	case singboxconfig.FieldNtpConfig:
		m.ResetNtpConfig()
		return nil
	case singboxconfig.FieldInbounds:
		m.ResetInbounds()
		return nil
	case singboxconfig.FieldOutbounds:
		m.ResetOutbounds()
		return nil
	case singboxconfig.FieldRouteConfig:
		m.ResetRouteConfig()
		return nil
	case singboxconfig.FieldExperimentalConfig:
		m.ResetExperimentalConfig()
		return nil
	case singboxconfig.FieldEndpoints:
		m.ResetEndpoints()
		return nil
	case singboxconfig.FieldCertificateConfig:
		m.ResetCertificateConfig()
		return nil
	}
	return fmt.Errorf("unknown SingBoxConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SingBoxConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SingBoxConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SingBoxConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SingBoxConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SingBoxConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SingBoxConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SingBoxConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SingBoxConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SingBoxConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SingBoxConfig edge %s", name)
}

// XrayConfigMutation represents an operation that mutates the XrayConfig nodes in the graph.
type XrayConfigMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	description       *string
	created_at        *time.Time
	updated_at        *time.Time
	log               **models.LogObject
	api               **models.APIObject
	dns               **models.DNSObject
	routing           **models.RoutingObject
	policy            **models.PolicyObject
	inbounds          *[]models.InboundObject
	appendinbounds    []models.InboundObject
	outbounds         *[]models.OutboundObject
	appendoutbounds   []models.OutboundObject
	transport         **models.TransportObject
	stats             **models.StatsObject
	reverse           **models.ReverseObject
	fakedns           **models.FakeDNSObject
	metrics           **models.MetricsObject
	observatory       **models.ObservatoryObject
	burst_observatory **models.BurstObservatoryObject
	services          *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*XrayConfig, error)
	predicates        []predicate.XrayConfig
}

var _ ent.Mutation = (*XrayConfigMutation)(nil)

// xrayconfigOption allows management of the mutation configuration using functional options.
type xrayconfigOption func(*XrayConfigMutation)

// newXrayConfigMutation creates new mutation for the XrayConfig entity.
func newXrayConfigMutation(c config, op Op, opts ...xrayconfigOption) *XrayConfigMutation {
	m := &XrayConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeXrayConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withXrayConfigID sets the ID field of the mutation.
func withXrayConfigID(id string) xrayconfigOption {
	return func(m *XrayConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *XrayConfig
		)
		m.oldValue = func(ctx context.Context) (*XrayConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().XrayConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withXrayConfig sets the old XrayConfig of the mutation.
func withXrayConfig(node *XrayConfig) xrayconfigOption {
	return func(m *XrayConfigMutation) {
		m.oldValue = func(context.Context) (*XrayConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m XrayConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m XrayConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of XrayConfig entities.
func (m *XrayConfigMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *XrayConfigMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *XrayConfigMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().XrayConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *XrayConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *XrayConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *XrayConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *XrayConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *XrayConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *XrayConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[xrayconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *XrayConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *XrayConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, xrayconfig.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *XrayConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *XrayConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *XrayConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *XrayConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *XrayConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *XrayConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLog sets the "log" field.
func (m *XrayConfigMutation) SetLog(mo *models.LogObject) {
	m.log = &mo
}

// Log returns the value of the "log" field in the mutation.
func (m *XrayConfigMutation) Log() (r *models.LogObject, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldLog(ctx context.Context) (v *models.LogObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ClearLog clears the value of the "log" field.
func (m *XrayConfigMutation) ClearLog() {
	m.log = nil
	m.clearedFields[xrayconfig.FieldLog] = struct{}{}
}

// LogCleared returns if the "log" field was cleared in this mutation.
func (m *XrayConfigMutation) LogCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldLog]
	return ok
}

// ResetLog resets all changes to the "log" field.
func (m *XrayConfigMutation) ResetLog() {
	m.log = nil
	delete(m.clearedFields, xrayconfig.FieldLog)
}

// SetAPI sets the "api" field.
func (m *XrayConfigMutation) SetAPI(mo *models.APIObject) {
	m.api = &mo
}

// API returns the value of the "api" field in the mutation.
func (m *XrayConfigMutation) API() (r *models.APIObject, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldAPI(ctx context.Context) (v *models.APIObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ClearAPI clears the value of the "api" field.
func (m *XrayConfigMutation) ClearAPI() {
	m.api = nil
	m.clearedFields[xrayconfig.FieldAPI] = struct{}{}
}

// APICleared returns if the "api" field was cleared in this mutation.
func (m *XrayConfigMutation) APICleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldAPI]
	return ok
}

// ResetAPI resets all changes to the "api" field.
func (m *XrayConfigMutation) ResetAPI() {
	m.api = nil
	delete(m.clearedFields, xrayconfig.FieldAPI)
}

// SetDNS sets the "dns" field.
func (m *XrayConfigMutation) SetDNS(mo *models.DNSObject) {
	m.dns = &mo
}

// DNS returns the value of the "dns" field in the mutation.
func (m *XrayConfigMutation) DNS() (r *models.DNSObject, exists bool) {
	v := m.dns
	if v == nil {
		return
	}
	return *v, true
}

// OldDNS returns the old "dns" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldDNS(ctx context.Context) (v *models.DNSObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNS: %w", err)
	}
	return oldValue.DNS, nil
}

// ClearDNS clears the value of the "dns" field.
func (m *XrayConfigMutation) ClearDNS() {
	m.dns = nil
	m.clearedFields[xrayconfig.FieldDNS] = struct{}{}
}

// DNSCleared returns if the "dns" field was cleared in this mutation.
func (m *XrayConfigMutation) DNSCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldDNS]
	return ok
}

// ResetDNS resets all changes to the "dns" field.
func (m *XrayConfigMutation) ResetDNS() {
	m.dns = nil
	delete(m.clearedFields, xrayconfig.FieldDNS)
}

// SetRouting sets the "routing" field.
func (m *XrayConfigMutation) SetRouting(mo *models.RoutingObject) {
	m.routing = &mo
}

// Routing returns the value of the "routing" field in the mutation.
func (m *XrayConfigMutation) Routing() (r *models.RoutingObject, exists bool) {
	v := m.routing
	if v == nil {
		return
	}
	return *v, true
}

// OldRouting returns the old "routing" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldRouting(ctx context.Context) (v *models.RoutingObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouting: %w", err)
	}
	return oldValue.Routing, nil
}

// ClearRouting clears the value of the "routing" field.
func (m *XrayConfigMutation) ClearRouting() {
	m.routing = nil
	m.clearedFields[xrayconfig.FieldRouting] = struct{}{}
}

// RoutingCleared returns if the "routing" field was cleared in this mutation.
func (m *XrayConfigMutation) RoutingCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldRouting]
	return ok
}

// ResetRouting resets all changes to the "routing" field.
func (m *XrayConfigMutation) ResetRouting() {
	m.routing = nil
	delete(m.clearedFields, xrayconfig.FieldRouting)
}

// SetPolicy sets the "policy" field.
func (m *XrayConfigMutation) SetPolicy(mo *models.PolicyObject) {
	m.policy = &mo
}

// Policy returns the value of the "policy" field in the mutation.
func (m *XrayConfigMutation) Policy() (r *models.PolicyObject, exists bool) {
	v := m.policy
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicy returns the old "policy" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldPolicy(ctx context.Context) (v *models.PolicyObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicy: %w", err)
	}
	return oldValue.Policy, nil
}

// ClearPolicy clears the value of the "policy" field.
func (m *XrayConfigMutation) ClearPolicy() {
	m.policy = nil
	m.clearedFields[xrayconfig.FieldPolicy] = struct{}{}
}

// PolicyCleared returns if the "policy" field was cleared in this mutation.
func (m *XrayConfigMutation) PolicyCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldPolicy]
	return ok
}

// ResetPolicy resets all changes to the "policy" field.
func (m *XrayConfigMutation) ResetPolicy() {
	m.policy = nil
	delete(m.clearedFields, xrayconfig.FieldPolicy)
}

// SetInbounds sets the "inbounds" field.
func (m *XrayConfigMutation) SetInbounds(mo []models.InboundObject) {
	m.inbounds = &mo
	m.appendinbounds = nil
}

// Inbounds returns the value of the "inbounds" field in the mutation.
func (m *XrayConfigMutation) Inbounds() (r []models.InboundObject, exists bool) {
	v := m.inbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldInbounds returns the old "inbounds" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldInbounds(ctx context.Context) (v []models.InboundObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInbounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInbounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInbounds: %w", err)
	}
	return oldValue.Inbounds, nil
}

// AppendInbounds adds mo to the "inbounds" field.
func (m *XrayConfigMutation) AppendInbounds(mo []models.InboundObject) {
	m.appendinbounds = append(m.appendinbounds, mo...)
}

// AppendedInbounds returns the list of values that were appended to the "inbounds" field in this mutation.
func (m *XrayConfigMutation) AppendedInbounds() ([]models.InboundObject, bool) {
	if len(m.appendinbounds) == 0 {
		return nil, false
	}
	return m.appendinbounds, true
}

// ClearInbounds clears the value of the "inbounds" field.
func (m *XrayConfigMutation) ClearInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	m.clearedFields[xrayconfig.FieldInbounds] = struct{}{}
}

// InboundsCleared returns if the "inbounds" field was cleared in this mutation.
func (m *XrayConfigMutation) InboundsCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldInbounds]
	return ok
}

// ResetInbounds resets all changes to the "inbounds" field.
func (m *XrayConfigMutation) ResetInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	delete(m.clearedFields, xrayconfig.FieldInbounds)
}

// SetOutbounds sets the "outbounds" field.
func (m *XrayConfigMutation) SetOutbounds(mo []models.OutboundObject) {
	m.outbounds = &mo
	m.appendoutbounds = nil
}

// Outbounds returns the value of the "outbounds" field in the mutation.
func (m *XrayConfigMutation) Outbounds() (r []models.OutboundObject, exists bool) {
	v := m.outbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldOutbounds returns the old "outbounds" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldOutbounds(ctx context.Context) (v []models.OutboundObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutbounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutbounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutbounds: %w", err)
	}
	return oldValue.Outbounds, nil
}

// AppendOutbounds adds mo to the "outbounds" field.
func (m *XrayConfigMutation) AppendOutbounds(mo []models.OutboundObject) {
	m.appendoutbounds = append(m.appendoutbounds, mo...)
}

// AppendedOutbounds returns the list of values that were appended to the "outbounds" field in this mutation.
func (m *XrayConfigMutation) AppendedOutbounds() ([]models.OutboundObject, bool) {
	if len(m.appendoutbounds) == 0 {
		return nil, false
	}
	return m.appendoutbounds, true
}

// ClearOutbounds clears the value of the "outbounds" field.
func (m *XrayConfigMutation) ClearOutbounds() {
	m.outbounds = nil
	m.appendoutbounds = nil
	m.clearedFields[xrayconfig.FieldOutbounds] = struct{}{}
}

// OutboundsCleared returns if the "outbounds" field was cleared in this mutation.
func (m *XrayConfigMutation) OutboundsCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldOutbounds]
	return ok
}

// ResetOutbounds resets all changes to the "outbounds" field.
func (m *XrayConfigMutation) ResetOutbounds() {
	m.outbounds = nil
	m.appendoutbounds = nil
	delete(m.clearedFields, xrayconfig.FieldOutbounds)
}

// SetTransport sets the "transport" field.
func (m *XrayConfigMutation) SetTransport(mo *models.TransportObject) {
	m.transport = &mo
}

// Transport returns the value of the "transport" field in the mutation.
func (m *XrayConfigMutation) Transport() (r *models.TransportObject, exists bool) {
	v := m.transport
	if v == nil {
		return
	}
	return *v, true
}

// OldTransport returns the old "transport" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldTransport(ctx context.Context) (v *models.TransportObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransport: %w", err)
	}
	return oldValue.Transport, nil
}

// ClearTransport clears the value of the "transport" field.
func (m *XrayConfigMutation) ClearTransport() {
	m.transport = nil
	m.clearedFields[xrayconfig.FieldTransport] = struct{}{}
}

// TransportCleared returns if the "transport" field was cleared in this mutation.
func (m *XrayConfigMutation) TransportCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldTransport]
	return ok
}

// ResetTransport resets all changes to the "transport" field.
func (m *XrayConfigMutation) ResetTransport() {
	m.transport = nil
	delete(m.clearedFields, xrayconfig.FieldTransport)
}

// SetStats sets the "stats" field.
func (m *XrayConfigMutation) SetStats(mo *models.StatsObject) {
	m.stats = &mo
}

// Stats returns the value of the "stats" field in the mutation.
func (m *XrayConfigMutation) Stats() (r *models.StatsObject, exists bool) {
	v := m.stats
	if v == nil {
		return
	}
	return *v, true
}

// OldStats returns the old "stats" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldStats(ctx context.Context) (v *models.StatsObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStats: %w", err)
	}
	return oldValue.Stats, nil
}

// ClearStats clears the value of the "stats" field.
func (m *XrayConfigMutation) ClearStats() {
	m.stats = nil
	m.clearedFields[xrayconfig.FieldStats] = struct{}{}
}

// StatsCleared returns if the "stats" field was cleared in this mutation.
func (m *XrayConfigMutation) StatsCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldStats]
	return ok
}

// ResetStats resets all changes to the "stats" field.
func (m *XrayConfigMutation) ResetStats() {
	m.stats = nil
	delete(m.clearedFields, xrayconfig.FieldStats)
}

// SetReverse sets the "reverse" field.
func (m *XrayConfigMutation) SetReverse(mo *models.ReverseObject) {
	m.reverse = &mo
}

// Reverse returns the value of the "reverse" field in the mutation.
func (m *XrayConfigMutation) Reverse() (r *models.ReverseObject, exists bool) {
	v := m.reverse
	if v == nil {
		return
	}
	return *v, true
}

// OldReverse returns the old "reverse" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldReverse(ctx context.Context) (v *models.ReverseObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReverse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReverse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReverse: %w", err)
	}
	return oldValue.Reverse, nil
}

// ClearReverse clears the value of the "reverse" field.
func (m *XrayConfigMutation) ClearReverse() {
	m.reverse = nil
	m.clearedFields[xrayconfig.FieldReverse] = struct{}{}
}

// ReverseCleared returns if the "reverse" field was cleared in this mutation.
func (m *XrayConfigMutation) ReverseCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldReverse]
	return ok
}

// ResetReverse resets all changes to the "reverse" field.
func (m *XrayConfigMutation) ResetReverse() {
	m.reverse = nil
	delete(m.clearedFields, xrayconfig.FieldReverse)
}

// SetFakedns sets the "fakedns" field.
func (m *XrayConfigMutation) SetFakedns(mdo *models.FakeDNSObject) {
	m.fakedns = &mdo
}

// Fakedns returns the value of the "fakedns" field in the mutation.
func (m *XrayConfigMutation) Fakedns() (r *models.FakeDNSObject, exists bool) {
	v := m.fakedns
	if v == nil {
		return
	}
	return *v, true
}

// OldFakedns returns the old "fakedns" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldFakedns(ctx context.Context) (v *models.FakeDNSObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFakedns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFakedns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFakedns: %w", err)
	}
	return oldValue.Fakedns, nil
}

// ClearFakedns clears the value of the "fakedns" field.
func (m *XrayConfigMutation) ClearFakedns() {
	m.fakedns = nil
	m.clearedFields[xrayconfig.FieldFakedns] = struct{}{}
}

// FakednsCleared returns if the "fakedns" field was cleared in this mutation.
func (m *XrayConfigMutation) FakednsCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldFakedns]
	return ok
}

// ResetFakedns resets all changes to the "fakedns" field.
func (m *XrayConfigMutation) ResetFakedns() {
	m.fakedns = nil
	delete(m.clearedFields, xrayconfig.FieldFakedns)
}

// SetMetrics sets the "metrics" field.
func (m *XrayConfigMutation) SetMetrics(mo *models.MetricsObject) {
	m.metrics = &mo
}

// Metrics returns the value of the "metrics" field in the mutation.
func (m *XrayConfigMutation) Metrics() (r *models.MetricsObject, exists bool) {
	v := m.metrics
	if v == nil {
		return
	}
	return *v, true
}

// OldMetrics returns the old "metrics" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldMetrics(ctx context.Context) (v *models.MetricsObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetrics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetrics: %w", err)
	}
	return oldValue.Metrics, nil
}

// ClearMetrics clears the value of the "metrics" field.
func (m *XrayConfigMutation) ClearMetrics() {
	m.metrics = nil
	m.clearedFields[xrayconfig.FieldMetrics] = struct{}{}
}

// MetricsCleared returns if the "metrics" field was cleared in this mutation.
func (m *XrayConfigMutation) MetricsCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldMetrics]
	return ok
}

// ResetMetrics resets all changes to the "metrics" field.
func (m *XrayConfigMutation) ResetMetrics() {
	m.metrics = nil
	delete(m.clearedFields, xrayconfig.FieldMetrics)
}

// SetObservatory sets the "observatory" field.
func (m *XrayConfigMutation) SetObservatory(mo *models.ObservatoryObject) {
	m.observatory = &mo
}

// Observatory returns the value of the "observatory" field in the mutation.
func (m *XrayConfigMutation) Observatory() (r *models.ObservatoryObject, exists bool) {
	v := m.observatory
	if v == nil {
		return
	}
	return *v, true
}

// OldObservatory returns the old "observatory" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldObservatory(ctx context.Context) (v *models.ObservatoryObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObservatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObservatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObservatory: %w", err)
	}
	return oldValue.Observatory, nil
}

// ClearObservatory clears the value of the "observatory" field.
func (m *XrayConfigMutation) ClearObservatory() {
	m.observatory = nil
	m.clearedFields[xrayconfig.FieldObservatory] = struct{}{}
}

// ObservatoryCleared returns if the "observatory" field was cleared in this mutation.
func (m *XrayConfigMutation) ObservatoryCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldObservatory]
	return ok
}

// ResetObservatory resets all changes to the "observatory" field.
func (m *XrayConfigMutation) ResetObservatory() {
	m.observatory = nil
	delete(m.clearedFields, xrayconfig.FieldObservatory)
}

// SetBurstObservatory sets the "burst_observatory" field.
func (m *XrayConfigMutation) SetBurstObservatory(moo *models.BurstObservatoryObject) {
	m.burst_observatory = &moo
}

// BurstObservatory returns the value of the "burst_observatory" field in the mutation.
func (m *XrayConfigMutation) BurstObservatory() (r *models.BurstObservatoryObject, exists bool) {
	v := m.burst_observatory
	if v == nil {
		return
	}
	return *v, true
}

// OldBurstObservatory returns the old "burst_observatory" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldBurstObservatory(ctx context.Context) (v *models.BurstObservatoryObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBurstObservatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBurstObservatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBurstObservatory: %w", err)
	}
	return oldValue.BurstObservatory, nil
}

// ClearBurstObservatory clears the value of the "burst_observatory" field.
func (m *XrayConfigMutation) ClearBurstObservatory() {
	m.burst_observatory = nil
	m.clearedFields[xrayconfig.FieldBurstObservatory] = struct{}{}
}

// BurstObservatoryCleared returns if the "burst_observatory" field was cleared in this mutation.
func (m *XrayConfigMutation) BurstObservatoryCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldBurstObservatory]
	return ok
}

// ResetBurstObservatory resets all changes to the "burst_observatory" field.
func (m *XrayConfigMutation) ResetBurstObservatory() {
	m.burst_observatory = nil
	delete(m.clearedFields, xrayconfig.FieldBurstObservatory)
}

// SetServices sets the "services" field.
func (m *XrayConfigMutation) SetServices(value map[string]interface{}) {
	m.services = &value
}

// Services returns the value of the "services" field in the mutation.
func (m *XrayConfigMutation) Services() (r map[string]interface{}, exists bool) {
	v := m.services
	if v == nil {
		return
	}
	return *v, true
}

// OldServices returns the old "services" field's value of the XrayConfig entity.
// If the XrayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *XrayConfigMutation) OldServices(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServices is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServices requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServices: %w", err)
	}
	return oldValue.Services, nil
}

// ClearServices clears the value of the "services" field.
func (m *XrayConfigMutation) ClearServices() {
	m.services = nil
	m.clearedFields[xrayconfig.FieldServices] = struct{}{}
}

// ServicesCleared returns if the "services" field was cleared in this mutation.
func (m *XrayConfigMutation) ServicesCleared() bool {
	_, ok := m.clearedFields[xrayconfig.FieldServices]
	return ok
}

// ResetServices resets all changes to the "services" field.
func (m *XrayConfigMutation) ResetServices() {
	m.services = nil
	delete(m.clearedFields, xrayconfig.FieldServices)
}

// Where appends a list predicates to the XrayConfigMutation builder.
func (m *XrayConfigMutation) Where(ps ...predicate.XrayConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the XrayConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *XrayConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.XrayConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *XrayConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *XrayConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (XrayConfig).
func (m *XrayConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *XrayConfigMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, xrayconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, xrayconfig.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, xrayconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, xrayconfig.FieldUpdatedAt)
	}
	if m.log != nil {
		fields = append(fields, xrayconfig.FieldLog)
	}
	if m.api != nil {
		fields = append(fields, xrayconfig.FieldAPI)
	}
	if m.dns != nil {
		fields = append(fields, xrayconfig.FieldDNS)
	}
	if m.routing != nil {
		fields = append(fields, xrayconfig.FieldRouting)
	}
	if m.policy != nil {
		fields = append(fields, xrayconfig.FieldPolicy)
	}
	if m.inbounds != nil {
		fields = append(fields, xrayconfig.FieldInbounds)
	}
	if m.outbounds != nil {
		fields = append(fields, xrayconfig.FieldOutbounds)
	}
	if m.transport != nil {
		fields = append(fields, xrayconfig.FieldTransport)
	}
	if m.stats != nil {
		fields = append(fields, xrayconfig.FieldStats)
	}
	if m.reverse != nil {
		fields = append(fields, xrayconfig.FieldReverse)
	}
	if m.fakedns != nil {
		fields = append(fields, xrayconfig.FieldFakedns)
	}
	if m.metrics != nil {
		fields = append(fields, xrayconfig.FieldMetrics)
	}
	if m.observatory != nil {
		fields = append(fields, xrayconfig.FieldObservatory)
	}
	if m.burst_observatory != nil {
		fields = append(fields, xrayconfig.FieldBurstObservatory)
	}
	if m.services != nil {
		fields = append(fields, xrayconfig.FieldServices)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *XrayConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case xrayconfig.FieldName:
		return m.Name()
	case xrayconfig.FieldDescription:
		return m.Description()
	case xrayconfig.FieldCreatedAt:
		return m.CreatedAt()
	case xrayconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case xrayconfig.FieldLog:
		return m.Log()
	case xrayconfig.FieldAPI:
		return m.API()
	case xrayconfig.FieldDNS:
		return m.DNS()
	case xrayconfig.FieldRouting:
		return m.Routing()
	case xrayconfig.FieldPolicy:
		return m.Policy()
	case xrayconfig.FieldInbounds:
		return m.Inbounds()
	case xrayconfig.FieldOutbounds:
		return m.Outbounds()
	case xrayconfig.FieldTransport:
		return m.Transport()
	case xrayconfig.FieldStats:
		return m.Stats()
	case xrayconfig.FieldReverse:
		return m.Reverse()
	case xrayconfig.FieldFakedns:
		return m.Fakedns()
	case xrayconfig.FieldMetrics:
		return m.Metrics()
	case xrayconfig.FieldObservatory:
		return m.Observatory()
	case xrayconfig.FieldBurstObservatory:
		return m.BurstObservatory()
	case xrayconfig.FieldServices:
		return m.Services()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *XrayConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case xrayconfig.FieldName:
		return m.OldName(ctx)
	case xrayconfig.FieldDescription:
		return m.OldDescription(ctx)
	case xrayconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case xrayconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case xrayconfig.FieldLog:
		return m.OldLog(ctx)
	case xrayconfig.FieldAPI:
		return m.OldAPI(ctx)
	case xrayconfig.FieldDNS:
		return m.OldDNS(ctx)
	case xrayconfig.FieldRouting:
		return m.OldRouting(ctx)
	case xrayconfig.FieldPolicy:
		return m.OldPolicy(ctx)
	case xrayconfig.FieldInbounds:
		return m.OldInbounds(ctx)
	case xrayconfig.FieldOutbounds:
		return m.OldOutbounds(ctx)
	case xrayconfig.FieldTransport:
		return m.OldTransport(ctx)
	case xrayconfig.FieldStats:
		return m.OldStats(ctx)
	case xrayconfig.FieldReverse:
		return m.OldReverse(ctx)
	case xrayconfig.FieldFakedns:
		return m.OldFakedns(ctx)
	case xrayconfig.FieldMetrics:
		return m.OldMetrics(ctx)
	case xrayconfig.FieldObservatory:
		return m.OldObservatory(ctx)
	case xrayconfig.FieldBurstObservatory:
		return m.OldBurstObservatory(ctx)
	case xrayconfig.FieldServices:
		return m.OldServices(ctx)
	}
	return nil, fmt.Errorf("unknown XrayConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *XrayConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case xrayconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case xrayconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case xrayconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case xrayconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case xrayconfig.FieldLog:
		v, ok := value.(*models.LogObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case xrayconfig.FieldAPI:
		v, ok := value.(*models.APIObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case xrayconfig.FieldDNS:
		v, ok := value.(*models.DNSObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNS(v)
		return nil
	case xrayconfig.FieldRouting:
		v, ok := value.(*models.RoutingObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouting(v)
		return nil
	case xrayconfig.FieldPolicy:
		v, ok := value.(*models.PolicyObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicy(v)
		return nil
	case xrayconfig.FieldInbounds:
		v, ok := value.([]models.InboundObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInbounds(v)
		return nil
	case xrayconfig.FieldOutbounds:
		v, ok := value.([]models.OutboundObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutbounds(v)
		return nil
	case xrayconfig.FieldTransport:
		v, ok := value.(*models.TransportObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransport(v)
		return nil
	case xrayconfig.FieldStats:
		v, ok := value.(*models.StatsObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStats(v)
		return nil
	case xrayconfig.FieldReverse:
		v, ok := value.(*models.ReverseObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReverse(v)
		return nil
	case xrayconfig.FieldFakedns:
		v, ok := value.(*models.FakeDNSObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFakedns(v)
		return nil
	case xrayconfig.FieldMetrics:
		v, ok := value.(*models.MetricsObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetrics(v)
		return nil
	case xrayconfig.FieldObservatory:
		v, ok := value.(*models.ObservatoryObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObservatory(v)
		return nil
	case xrayconfig.FieldBurstObservatory:
		v, ok := value.(*models.BurstObservatoryObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBurstObservatory(v)
		return nil
	case xrayconfig.FieldServices:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServices(v)
		return nil
	}
	return fmt.Errorf("unknown XrayConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *XrayConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *XrayConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *XrayConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown XrayConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *XrayConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(xrayconfig.FieldDescription) {
		fields = append(fields, xrayconfig.FieldDescription)
	}
	if m.FieldCleared(xrayconfig.FieldLog) {
		fields = append(fields, xrayconfig.FieldLog)
	}
	if m.FieldCleared(xrayconfig.FieldAPI) {
		fields = append(fields, xrayconfig.FieldAPI)
	}
	if m.FieldCleared(xrayconfig.FieldDNS) {
		fields = append(fields, xrayconfig.FieldDNS)
	}
	if m.FieldCleared(xrayconfig.FieldRouting) {
		fields = append(fields, xrayconfig.FieldRouting)
	}
	if m.FieldCleared(xrayconfig.FieldPolicy) {
		fields = append(fields, xrayconfig.FieldPolicy)
	}
	if m.FieldCleared(xrayconfig.FieldInbounds) {
		fields = append(fields, xrayconfig.FieldInbounds)
	}
	if m.FieldCleared(xrayconfig.FieldOutbounds) {
		fields = append(fields, xrayconfig.FieldOutbounds)
	}
	if m.FieldCleared(xrayconfig.FieldTransport) {
		fields = append(fields, xrayconfig.FieldTransport)
	}
	if m.FieldCleared(xrayconfig.FieldStats) {
		fields = append(fields, xrayconfig.FieldStats)
	}
	if m.FieldCleared(xrayconfig.FieldReverse) {
		fields = append(fields, xrayconfig.FieldReverse)
	}
	if m.FieldCleared(xrayconfig.FieldFakedns) {
		fields = append(fields, xrayconfig.FieldFakedns)
	}
	if m.FieldCleared(xrayconfig.FieldMetrics) {
		fields = append(fields, xrayconfig.FieldMetrics)
	}
	if m.FieldCleared(xrayconfig.FieldObservatory) {
		fields = append(fields, xrayconfig.FieldObservatory)
	}
	if m.FieldCleared(xrayconfig.FieldBurstObservatory) {
		fields = append(fields, xrayconfig.FieldBurstObservatory)
	}
	if m.FieldCleared(xrayconfig.FieldServices) {
		fields = append(fields, xrayconfig.FieldServices)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *XrayConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *XrayConfigMutation) ClearField(name string) error {
	switch name {
	case xrayconfig.FieldDescription:
		m.ClearDescription()
		return nil
	case xrayconfig.FieldLog:
		m.ClearLog()
		return nil
	case xrayconfig.FieldAPI:
		m.ClearAPI()
		return nil
	case xrayconfig.FieldDNS:
		m.ClearDNS()
		return nil
	case xrayconfig.FieldRouting:
		m.ClearRouting()
		return nil
	case xrayconfig.FieldPolicy:
		m.ClearPolicy()
		return nil
	case xrayconfig.FieldInbounds:
		m.ClearInbounds()
		return nil
	case xrayconfig.FieldOutbounds:
		m.ClearOutbounds()
		return nil
	case xrayconfig.FieldTransport:
		m.ClearTransport()
		return nil
	case xrayconfig.FieldStats:
		m.ClearStats()
		return nil
	case xrayconfig.FieldReverse:
		m.ClearReverse()
		return nil
	case xrayconfig.FieldFakedns:
		m.ClearFakedns()
		return nil
	case xrayconfig.FieldMetrics:
		m.ClearMetrics()
		return nil
	case xrayconfig.FieldObservatory:
		m.ClearObservatory()
		return nil
	case xrayconfig.FieldBurstObservatory:
		m.ClearBurstObservatory()
		return nil
	case xrayconfig.FieldServices:
		m.ClearServices()
		return nil
	}
	return fmt.Errorf("unknown XrayConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *XrayConfigMutation) ResetField(name string) error {
	switch name {
	case xrayconfig.FieldName:
		m.ResetName()
		return nil
	case xrayconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case xrayconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case xrayconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case xrayconfig.FieldLog:
		m.ResetLog()
		return nil
	case xrayconfig.FieldAPI:
		m.ResetAPI()
		return nil
	case xrayconfig.FieldDNS:
		m.ResetDNS()
		return nil
	case xrayconfig.FieldRouting:
		m.ResetRouting()
		return nil
	case xrayconfig.FieldPolicy:
		m.ResetPolicy()
		return nil
	case xrayconfig.FieldInbounds:
		m.ResetInbounds()
		return nil
	case xrayconfig.FieldOutbounds:
		m.ResetOutbounds()
		return nil
	case xrayconfig.FieldTransport:
		m.ResetTransport()
		return nil
	case xrayconfig.FieldStats:
		m.ResetStats()
		return nil
	case xrayconfig.FieldReverse:
		m.ResetReverse()
		return nil
	case xrayconfig.FieldFakedns:
		m.ResetFakedns()
		return nil
	case xrayconfig.FieldMetrics:
		m.ResetMetrics()
		return nil
	case xrayconfig.FieldObservatory:
		m.ResetObservatory()
		return nil
	case xrayconfig.FieldBurstObservatory:
		m.ResetBurstObservatory()
		return nil
	case xrayconfig.FieldServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown XrayConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *XrayConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *XrayConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *XrayConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *XrayConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *XrayConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *XrayConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *XrayConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown XrayConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *XrayConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown XrayConfig edge %s", name)
}
