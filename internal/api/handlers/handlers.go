package handlers

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/tools4net/ezfw/backend/internal/models"
	"github.com/tools4net/ezfw/backend/internal/store"
)

// ConfigHandler handles configuration-related HTTP requests
type ConfigHandler struct {
	store store.Store
}

// NewConfigHandler creates a new ConfigHandler instance
func NewConfigHandler(store store.Store) *ConfigHandler {
	return &ConfigHandler{
		store: store,
	}
}

// CreateSingBoxConfigHandler handles POST requests to create a new SingBox configuration
func (h *ConfigHandler) CreateSingBoxConfigHandler(c *gin.Context) {
	var config models.SingBoxConfig
	if err := c.ShouldBindJSON(&config); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.store.CreateSingBoxConfig(c.Request.Context(), &config); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, config)
}

// ListSingBoxConfigsHandler handles GET requests to list SingBox configurations
func (h *ConfigHandler) ListSingBoxConfigsHandler(c *gin.Context) {
	limit := 10
	offset := 0

	if l := c.Query("limit"); l != "" {
		if parsedLimit, err := strconv.Atoi(l); err == nil && parsedLimit > 0 {
			limit = parsedLimit
		}
	}

	if o := c.Query("offset"); o != "" {
		if parsedOffset, err := strconv.Atoi(o); err == nil && parsedOffset >= 0 {
			offset = parsedOffset
		}
	}

	configs, err := h.store.ListSingBoxConfigs(c.Request.Context(), limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"configs": configs})
}

// GetSingBoxConfigHandler handles GET requests to retrieve a specific SingBox configuration
func (h *ConfigHandler) GetSingBoxConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	config, err := h.store.GetSingBoxConfig(c.Request.Context(), configID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "configuration not found"})
		return
	}

	c.JSON(http.StatusOK, config)
}

// UpdateSingBoxConfigHandler handles PUT requests to update a SingBox configuration
func (h *ConfigHandler) UpdateSingBoxConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	var config models.SingBoxConfig
	if err := c.ShouldBindJSON(&config); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Ensure the ID matches the URL parameter
	config.ID = configID

	if err := h.store.UpdateSingBoxConfig(c.Request.Context(), &config); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, config)
}

// DeleteSingBoxConfigHandler handles DELETE requests to remove a SingBox configuration
func (h *ConfigHandler) DeleteSingBoxConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	if err := h.store.DeleteSingBoxConfig(c.Request.Context(), configID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "configuration deleted successfully"})
}

// GenerateSingBoxConfigHandler handles GET requests to generate a SingBox configuration file
func (h *ConfigHandler) GenerateSingBoxConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	config, err := h.store.GetSingBoxConfig(c.Request.Context(), configID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "configuration not found"})
		return
	}

	// Return the configuration in a format suitable for SingBox
	c.Header("Content-Type", "application/json")
	c.Header("Content-Disposition", "attachment; filename=singbox-config.json")
	c.JSON(http.StatusOK, config)
}

// CreateXrayConfigHandler handles POST requests to create a new Xray configuration
func (h *ConfigHandler) CreateXrayConfigHandler(c *gin.Context) {
	var config models.XrayConfig
	if err := c.ShouldBindJSON(&config); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	// Basic validation: Name is required
	if config.Name == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Configuration 'name' is required"})
		return
	}

	// ID will be generated by the store if not provided, or use provided if it is.
	// For Create, we typically let store handle ID generation.
	// If ID is provided by client during create, it might be overwritten or cause unique constraint issues if not careful.
	// Current store CreateXrayConfig generates a new UUID if config.ID is empty.

	if err := h.store.CreateXrayConfig(c.Request.Context(), &config); err != nil {
		// Check for unique constraint error on name (specific to SQLite error message)
		if err.Error().Contains("UNIQUE constraint failed: xray_configs.name") {
			c.JSON(http.StatusConflict, gin.H{"error": "Configuration name already exists"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create Xray configuration: " + err.Error()})
		return
	}

	c.JSON(http.StatusCreated, config)
}

// ListXrayConfigsHandler handles GET requests to list Xray configurations
func (h *ConfigHandler) ListXrayConfigsHandler(c *gin.Context) {
	limit := 10
	offset := 0

	if l := c.Query("limit"); l != "" {
		if parsedLimit, err := strconv.Atoi(l); err == nil && parsedLimit > 0 {
			limit = parsedLimit
		}
	}

	if o := c.Query("offset"); o != "" {
		if parsedOffset, err := strconv.Atoi(o); err == nil && parsedOffset >= 0 {
			offset = parsedOffset
		}
	}

	configs, err := h.store.ListXrayConfigs(c.Request.Context(), limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"configs": configs})
}

// GetXrayConfigHandler handles GET requests to retrieve a specific Xray configuration
func (h *ConfigHandler) GetXrayConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	config, err := h.store.GetXrayConfig(c.Request.Context(), configID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "configuration not found"})
		return
	}

	c.JSON(http.StatusOK, config)
}

// UpdateXrayConfigHandler handles PUT requests to update an Xray configuration
func (h *ConfigHandler) UpdateXrayConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	var config models.XrayConfig
	if err := c.ShouldBindJSON(&config); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload: " + err.Error()})
		return
	}

	// Basic validation: Name is required if being updated to a new value
	// If the name field is present in the payload and is empty, it's an error.
	// If the name field is not in the payload, it means the name is not being updated.
	if name, ok := c.Get("name"); ok && name.(string) == "" {
		// This check is a bit tricky with ShouldBindJSON as it depends on how partial updates are handled.
		// A simpler check is just on config.Name if it's expected to be part of the payload.
		// For a PUT, typically the full new state is expected.
		// If partial update (PATCH) was supported, this would be different.
	}
	// For PUT, usually, all fields that define the resource's identity or are required should be present.
	// Let's assume Name is required in the payload for an update.
	if config.Name == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Configuration 'name' cannot be empty for update"})
		return
	}


	// Ensure the ID matches the URL parameter
	config.ID = configID

	if err := h.store.UpdateXrayConfig(c.Request.Context(), &config); err != nil {
		// Check for unique constraint error on name
		if err.Error().Contains("UNIQUE constraint failed: xray_configs.name") {
			c.JSON(http.StatusConflict, gin.H{"error": "Configuration name already exists for another configuration"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update Xray configuration: " + err.Error()})
		return
	}

	c.JSON(http.StatusOK, config)
}

// DeleteXrayConfigHandler handles DELETE requests to remove an Xray configuration
func (h *ConfigHandler) DeleteXrayConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	if err := h.store.DeleteXrayConfig(c.Request.Context(), configID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "configuration deleted successfully"})
}

// GenerateXrayConfigHandler handles GET requests to generate an Xray configuration file
func (h *ConfigHandler) GenerateXrayConfigHandler(c *gin.Context) {
	configID := c.Param("configId")
	if configID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "config ID is required"})
		return
	}

	config, err := h.store.GetXrayConfig(c.Request.Context(), configID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "configuration not found"})
		return
	}

	// Return the configuration in a format suitable for Xray
	// We only want to marshal the core Xray fields, not our internal DB/API metadata
	xrayCoreConfig := gin.H{
		"log":               config.Log,
		"api":               config.API,
		"dns":               config.DNS,
		"routing":           config.Routing,
		"policy":            config.Policy,
		"inbounds":          config.Inbounds,
		"outbounds":         config.Outbounds,
		"transport":         config.Transport,
		"stats":             config.Stats,
		"reverse":           config.Reverse,
		"fakedns":           config.FakeDNS,
		"metrics":           config.Metrics,
		"observatory":       config.Observatory,
		"burstObservatory": config.BurstObservatory,
	}

	c.Header("Content-Type", "application/json")
	c.Header("Content-Disposition", "attachment; filename=xray-config-"+config.Name+".json") // Add config name to filename
	c.JSON(http.StatusOK, xrayCoreConfig)
}